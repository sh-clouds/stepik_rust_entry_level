Модуль std::fmt

Средства форматной строки поставляются из стандартной библиотеки std модуля fmt. Поскольку fmt входит в прелюдию, необходимости её подключения нет.



Параметры форматирования

Ширина

// Все эти примеры выводят "Hello x    !"
println!("Hello {:5}!", "x");
println!("Hello {:1$}!", "x", 5);
println!("Hello {1:0$}!", 5, "x");
println!("Hello {:width$}!", "x", width = 5);
let width = 5;
println!("Hello {:width$}!", "x");

                  
Параметр ширины задает минимальную ширину, которую должен занимать формат. Если аргумент не заполняет заданное количество символов, то оставшееся место заполнится указанным параметром "заполнение/выравнивание" (см. ниже).

Размер ширины также можно указать через список параметров с помощью постфикса $, указывающий, что второй аргумент определяет ширину. Однако обращение к аргументу с синтаксисом доллара не влияет на счётчик "следующего аргумента".  Поэтому обычно рекомендуется ссылаться на аргументы по позиции или использовать именованные аргументы.



Заполнение и выравнивание

println!("Hello {:<5}!", "x");  // "Hello x    !"
println!("Hello {:-<5}!", "x"); // "Hello x----!"
println!("Hello {:^5}!", "x");  // "Hello   x  !"
println!("Hello {:>5}!", "x");  // "Hello     x!"

                  
Обычно с параметром ширины указываются необязательный символ заполнения и выравнивания, которые определяются перед шириной, сразу после :. Если форматируемое значение меньше ширины, то оставшееся место заполнится, указанным символом. Заполнение возможно в следующих вариантах для разных выравниваний:

[заполнитель]< - аргумент выравнивается по левому краю по ширине столбцов;
[заполнитель]^ - аргумент выравнивается по центру по ширине столбцов;
[заполнитель]> - аргумент выравнивается по правому краю по ширине столбцов.
Скобки [] вокруг [заполнитель] в описании форматной строки указывают на то, что этот параметр является необязательным. Это распространённая практика в документации.

По умолчанию заполнителем для нечисловых символов является пробел с выравниванием по левому краю. Для чисел также используется по умолчанию заполнитель пробел, но с выравниваем по правому краю. Если для чисел указан флаг 0 (см. ниже), то неявным символом заполнения будет 0.

Выравнивание может не поддерживаться некоторыми типами. В частности, оно обычно не реализуется для типажа Debug:

println!("Hello {:^15}!", Some("hi")); // ошибка

                  
Для достижения желаемого результат рекомендуется отформатировать входные данные с помощью макроса format! (тема следующей части), а затем дополнить результирующую строку, чтобы получить выходные данные:

println!("Hello {:^15}!", format!("{:?}", Some("hi"))); // => "Hello   Some("hi")   !"

      

Знак числа, # и 0

println!("Hello {:+}!", 5); // "Hello +5!"
println!("{:#x}!", 27); // "0x1b!"
println!("Hello {:05}!", 5); // "Hello 00005!"
println!("Hello {:05}!", -5); // "Hello -0005!"
println!("{:#010x}!", 27); // "0x0000001b!"

                  
Рассмотрим флаги, изменяющие поведение форматтера.

+ - предназначен для числовых типов и указывает на то, что знак всегда следует печатать. По умолчанию, т.е. без указания знака + печатается только отрицательный знак знаковых чисел, а знак положительных или беззнаковых значений опускается. Флаг + позволяет печатать знак + или - всегда;

- - в настоящее время не используется;

# - указывает на то, что следует использовать "альтернативную" форму печати. Альтернативные формы:

#? - красиво распечатать отладочное (Debug) форматирование (добавляет разрывы строк и отступы);
#x - предваряет аргумент 0x;
#X - предваряет аргумент 0x;
#b - предваряет аргумент 0b;
#o - предваряет аргумент 0o.
0 - используется с целочисленными форматами для указания того, что заполнение ширины должно выполняться как с помощью символа нуля, так и знаков. К примеру, формат {:08} для целого числа 1 вернёт 00000001, а для -1  -0000001. Обратите внимание, что для -1 нулей на одну единицу меньше, чем в 1, и что нули всегда ставятся после знака (если он есть) и перед цифрами.
При использовании вместе с флагом # применяется аналогичное правило: дополнительные нули вставляются после префикса, но перед цифрами. Префикс включается в общую ширину. Флаг 0 переопределяет символ заполнения и флаг выравнивания, заставляя числа выравниваться по правому краю с нулями, несмотря на использование отличного флага выравнивания.



Точность

Для нечисловых типов точность можно считать "максимальной шириной". Если результирующая строка длиннее этой ширины, она усекается до указанного количества символов, и это усечённое значение выдаётся с правильным заполнением, выравниванием и шириной, если, конечно, эти параметры установлены.

Для целочисленных типов точность игнорируется.

Для вещественных типов точность указывает, сколько цифр после десятичной точки должно быть напечатано.

Есть три способа указать желаемую точность. Все примеры выводят одно и то же  Hello x is 0.01000:

1. Используя целое число N и точку: .N:

// Hello {arg 0 ("x")} is {arg 1 (0.01) с точностью, указанной в форматной строке (5)}
println!("Hello {0} is {1:.5}", "x", 0.01);

                  
2. Используя позиционный или именованный аргумент типа usize, за которым следует знак доллара: .N$:

// Hello {arg 1 ("x")} is {arg 2 (0.01) с точностью, указанной в arg 0 (5)}
println!("Hello {1} is {2:.0$}", 5, "x", 0.01);

// Hello {arg 0 ("x")} is {arg 2 (0.01) с точностью, указанной в arg 1 (5)}
println!("Hello {0} is {2:.1$}", "x", 5, 0.01);

// Hello {next arg -> arg 0 ("x")} is {arg "number" (0.01) с точностью, указанной в arg "prec" (5)}
println!("Hello {} is {number:.prec$}", "x", prec = 5, number = 0.01);

                  
3. Используя точку и звёздочку. .* означает, что заполнитель {...} связан с двумя форматами входных данных, а не с одним:

Если используется форматная строка в виде {:<spec>.*}, то первый входной аргумент типа usize задаёт точность, а второй - значение для печати.
// Hello {next arg -> arg 0 ("x")} is {second of next two args -> arg 2 (0.01) с точностью, указанной в first of next two args -> arg 1 (5)}
println!("Hello {} is {:.*}",    "x", 5, 0.01);

                  
<spec> (опционально) - это спецификатор, определяющий, как именно должно быть отформатировано значение. Спецификатор включает в себя такие элементы, как ширина поля, символ заполнения, выравнивание, префиксы и т.д.
// Hello {следующий аргумент -> arg 0 ("x")} is {второй из следующих двух аргументов -> arg 2 (0.01) с точность, указанной в первом из следующих двух аргументов -> arg 1 (5)}
println!("Hello {} is {:.*}",    "x", 5, 0.01);

                  
Если используется форматная строка в виде {<arg>:<spec>.*} , то <arg> задаёт значение для печати, а точность берётся так, как если бы она была указана с опущенным позиционным параметром ({} вместо {<arg>:}):
// Hello {arg 1 ("x")} is {arg 2 (0.01) с точностью, указанной в следующем аргументе -> arg 0 (5)}
println!("Hello {1} is {2:.*}",  5, "x", 0.01);

// Hello {next arg -> arg 0 ("x")} is {arg 2 (0.01) с точностью, указанной в следующем аргументе -> arg 1 (5)}
println!("Hello {} is {2:.*}",   "x", 5, 0.01);

                  
Символы <> в документации используются для обозначения параметров, которые должны быть заменены конкретными значениями при использовании.
Рассмотрим ещё примеры:

println!("{}, `{name:.*}` has 3 fractional digits", "Hello", 3, name=1234.56);
println!("{}, `{name:.*}` has 3 characters", "Hello", 3, name="1234.56");
println!("{}, `{name:>8.*}` has 3 right-aligned characters", "Hello", 3, name="1234.56");

                  
Теперь вывод немного иной:

Hello, `1234.560` has 3 fractional digits
Hello, `123` has 3 characters
Hello, `     123` has 3 right-aligned characters

                  
При усечении вещественных значений Rust использует округление до ближайшего чётного, что является режимом округления по умолчанию в IEEE 754. Например,

println!("{0:.1$e}", 12345, 3);
println!("{0:.1$e}", 12355, 3);

                  
выведет:

1.234e4
1.236e4

      

Локализация

В некоторых языках программирования поведение форматной строки зависит от настроек локали операционной системы. Средства форматирования, предоставляемые стандартной библиотекой Rust, не зависят от настроек и дают одинаковые результаты во всех системах, независимо от конфигураций.

К примеру, следующий код всегда будет печатать 1.5, даже если в языковом стандарте системы в качестве десятичного разделителя используется отличный от точки символ.

println!("The value is {}", 1.5);

      

Экранирование

Литеральные символы { и } могут быть включены в строку, указав перед ними тот же символ. Так символ { экранируется с помощью {{, а } с помощью }}.

println!("Hello {{}}"); // "Hello {}"
println!("{{ Hello"); // "{ Hello"
println!("Hello }}"); // "Hello }"