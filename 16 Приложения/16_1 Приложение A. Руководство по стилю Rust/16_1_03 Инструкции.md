Инструкции

let инструкции

Ставьте пробел после : и по обе стороны от = (если они присутствуют). Но не перед точкой с запятой.

let pattern; // ok
let pattern: Type = expr; // ok
let pattern: Type; // ok
let pattern = expr; // ok

let pattern ; // nope
let pattern: Type= expr; // nope
let pattern:Type; // nope
let pattern=expr; // nope

                  
Если возможно, отформатируйте объявление в одну строку. Если нет, попробуйте разделить его после символа =, если, конечно, объявление помещается в двух строках. В этом случае сделайте отступ для выражения:

let pattern: Type =
    expr;

                  
Если первая строка по-прежнему не помещается в одну строку, разделите её после : и используйте блочный отступ. Если тип требует нескольких строк даже после разбивки, то поместите первую строку в ту же строку, что и :, в соответствии с правилами объединения:

let pattern:
    Type =
    expr;

                  
Например:

let Foo {
    f: abcd,
    g: qwer,
}: Foo<Bar> =
    Foo { f, g };

let (abcd,
    defg):
    Baz =
{ ... }

                  
Если выражение занимает несколько строк:

let foo = Foo { f: abcd, g: qwer };

let foo: Type = { an_expression(); ... };

                  
То если первая строка выражения помещается в оставшееся пространство, оно остаётся на той же строке, что и =, а остальная часть выражения остаётся без дополнительного отступа:

let foo = Foo {
    f: abcd,
    g: qwer,
};

let foo: Type = {
    an_expression();
    ...
};

                  
Если первая строка не помещается, то поместите выражение в последующие строки, сделав блочный отступ:

let foo =
    ALongName {
        f: abcd,
        g: qwer,
    };

                  
Если выражение представляет собой блок, а тип или шаблон охватывают несколько строк, поставьте открывающую фигурную скобку на новой строке без отступа (это обеспечивает отделение внутренней части блока от типа), в противном случае открывающая фигурная скобка следует за символом =:

let foo:
    ALongType =
{
    an_expression();
    ...
};

let Foo {
    f: abcd,
    g: qwer,
}: Foo<Bar> = Foo {
    f: blimblimblim,
    g: blamblamblam,
};

let Foo {
    f: abcd,
    g: qwer,
}: Foo<Bar> = foo(
    blimblimblim,
    blamblamblam,
);

                

блоки else / let-else инструкции

Оператор let может содержать компонент else, что делает его let-else инструкцией. В этом случае всегда применяйте те же правила форматирования к компонентам, которые предшествуют блоку else, т.е. к шаблону let: Type = initializer_expr, как описано выше для других операторов let.

Форматируйте всю инструкцию let-else в одну строку, если все приведённые ниже условия выполняются:

вся инструкция короткая;
блок else содержит только однострочное выражение и никаких инструкций;
блок else не содержит комментариев;
компоненты инструкции let, предшествующие блоку else, могут быть отформатированы в одну строку.
let Some(1) = opt else { return };

                  
В противном случае оператор let-else требует некоторых переносов строк.

Если инструкция let-else разбивается на несколько строк, никогда не делайте разрыв (перенос) между else и {, т.е. не переносите на новую строку, но всегда ставьте перед }.

// ok
let Some(value) = option else {
    return;
};

// nope
let Some(value) = option else
{
    return;
};

                  
Если компоненты инструкции let, предшествующие else, могут быть отформатированы в одну строку, но let-else не подходит для размещения полностью в одной строке, поместите else { на ту же строку, что и инициализирующее выражение, с пробелом между ними, а затем разбейте строку после {. Сделайте отступ в закрывающей } таким, чтобы он соответствовал отступу инструкции let и отступите в содержащемся блоке ещё на один шаг больше.

let Some(1) = opt else {
    return;
};

let Some(1) = opt else {
    // nope
    return
};

                  
Если компоненты инструкции let, предшествующие else, могут быть отформатированы в одну строку, но else { не помещается в той же строке, разбейте строку перед else.

    let Some(x) = some_really_really_really_really_really_really_really_really_really_long_name
    else {
        return;
    };

                  
Если инициализирующее выражение состоит из нескольких строк, помещайте ключевое слово else и открывающую фигурную скобку блока { в ту же строку, что и конец инициализирующего выражения с пробелом между ними, тогда и только тогда, когда все приведённые ниже условия выполняются:

Инициализирующее выражение заканчивается одной или несколькими закрывающими круглыми, квадратными и/или фигурными скобками;
В этой строке больше ничего нет;
Эта строка имеет тот же уровень отступа, что и исходное ключевое слово let.
К примеру:

let Some(x) = y.foo(
    "abc",
    fairly_long_identifier,
    "def",
    "123456",
    "string",
    "cheese",
) else {
    bar()
}

                  
В противном случае поместите ключевое слово else и открывающую фигурную скобку в следующую строку после окончания инициализирующего выражения. При этом ключевое слово else должно располагаться на том же уровне отступа, что и ключевое слово let.

К примеру:

fn main() {
    let Some(x) = abcdef()
        .foo(
            "abc",
            some_really_really_really_long_ident,
            "ident",
            "123456",
        )
        .bar()
        .baz()
        .qux("fffffffffffffffff")
    else {
        return
    };

    let Some(aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa) =
        bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb
    else {
        return;
    };

    let LongStructName(AnotherStruct {
        multi,
        line,
        pattern,
    }) = slice.as_ref()
    else {
        return;
    };

    let LongStructName(AnotherStruct {
        multi,
        line,
        pattern,
    }) = multi_line_function_call(
        arg1,
        arg2,
        arg3,
        arg4,
    ) else {
        return;
    };
}

    

Макросы в роли инструкций

При использовании макроса в позиции инструкции используйте круглые или квадратные скобки в качестве разделителей и завершайте их точкой с запятой. Не ставьте пробелы вокруг имени, !, разделителей или ;.

a_macro!(argument); // ok
a_macro! (argument); // nope
a_macro!(argument) ; // nope
a_macro!( argument ); // nope


                  

Выражения в роли инструкций

Не ставьте пробел между выражением и точкой с запятой:

<expr>; // ok
<expr> ; // nope

                  
Завершайте все выражения в позиции инструкций точкой с запятой, если только они не заканчиваются конструкцией блочного выражения {} или не используются в качестве его возвращаемого значения:

{
    an_expression(); // ok
    expr_as_value() // ok
}

return foo(); // ok

loop {
    break; // ok
}

fn main() {
    if 5 > 3 {

    } // ok
}

fn main() {
    if 5 > 3 {

    }; // nope
}

                  
Используйте точку с запятой там, где выражение имеет пустой тип, даже если оно может быть использовано:

fn foo() { ... }

fn bar() {
    foo(); // ok
    foo() // nope
}