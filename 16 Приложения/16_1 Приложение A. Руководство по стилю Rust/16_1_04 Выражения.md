Выражения

Блоки

Блочное выражение (блок) должно содержать новую строку после начальной скобки { и перед конечной скобкой }, если только его нельзя записать в одну строку в соответствии с другим правилом стиля:

fn block_as_stmt() {
    a_call();

    {
        a_call_inside_a_block();

        // a comment in a block
        the_value
    }
}

fn block_as_expr() {
    let foo = {
        a_call_inside_a_block();

        // a comment in a block
        the_value
    };
}

                  
Ключевое слово перед блочным выражением (например, unsafe или async) должно находиться на той же строке, что и открывающая фигурная скобка с одним пробелом между ключевым словом и скобкой. Содержимое блока должно быть с отступом.

fn unsafe_block_as_stmt() {
    a_call();

    unsafe { // ok
        a_call_inside_a_block();

        // a comment in a block
        the_value
    }
}

                  
Если у блочного выражения есть атрибут, поместите его в отдельную строку перед блоком:

fn block_as_stmt() {
    #[an_attribute] // ok
    {
        #![an_inner_attribute]

        // a comment in a block
        the_value
    }
}

                  
Избегайте комментариев в тех же строках, что и фигурные скобки.

Записывайте пустое блочное выражение как {}.

Пишите блочное выражение в одну строку, если:

он либо используется в роли выражения (а, не в роли инструкции), либо является небезопасным блоком в роли инструкции,
содержит однострочное выражение и не содержит инструкций,
и не содержит комментариев.
Для однострочного блочного выражения указывайте пробелы после открывающей и закрывающей фигурной скобкой:

fn main() {
    // Однострочный формат
    let _ = { a_call() }; // ok
    let _ = {a_call()}; // nope
    let _ = unsafe { a_call() }; // ok

    // Не допускается в одну строку
    // Позиция инструкции.
    {
        a_call()
    };

    // Содержит инструкцию
    let _ = {
        a_call();
    };
    unsafe {
        a_call();
    }

    // Содержит комментарий
    let _ = {
        // A comment
    };
    let _ = {
        // A comment
        a_call()
    };

    // Многострочный формат
    let _ = {
        a_call();
        another_call()
    };
    let _ = {
        a_call(
            an_argument,
            another_arg,
        )
    };
}

          

Кортежные литералы

По возможности используйте однострочную форму. Не ставьте пробелы между открывающей круглой скобкой и первым элементом, а также между последним элементом и закрывающей круглой скобкой. Разделяйте элементы запятой, за которой следует пробел.

Если однострочная форма невозможна, записывайте кортеж в несколько строк, чтобы каждый элемент кортежа располагался на отдельной строке с блочным отступом, и используйте конечную запятую."

(a, b, c)

let x = (
    a_long_expr,
    another_very_long_expr,
);

                

Литералы массивов

Записывайте литералы небольших массивов в одну строку. Не ставьте пробелы между открывающей квадратной скобкой и первым элементом, а также между последним элементом и закрывающей квадратной скобкой. Разделяйте элементы запятой, за которой следует пробел.

Если используется повторяющийся инициализатор (например, [0; 10]) ставьте пробел только после точки с запятой.

Применяйте те же правила при использовании vec! или аналогичных массивоподобных макросов. Всегда используйте квадратные скобки с такими макросами, т.е. при использовании макросов, которые создают массивы или похожие структуры данных, следует обрамлять элементы квадратными скобками:

fn main() {
    let x = [1, 2, 3];
    let y = vec![a, b, c, d];
    let a = [42; 10];
}

                  
Для массивов, которые необходимо разбивать на строки, при использовании повторяющегося инициализатора делайте разбиение после ;, а не перед ним. В остальных случаях следуйте приведенным ниже правилам для вызовов функций. В любом случае выделяйте содержимое инициализатора блочными отступами и ставьте разрывы (переносы) строк после открывающей квадратной скобки и перед закрывающей квадратной скобкой:

fn main() {
    [
        a_long_expression();
        1234567890
    ]
    let x = [
        an_expression,
        another_expression,
        a_third_expression,
    ];
}

                  

Доступ к массиву, индексация и нарезка

Не ставьте пробелы вокруг квадратных скобок. По возможности избегайте переноса строк. Никогда не переносите строку между целевым (индексируемым) выражением и открывающей квадратной скобкой. Если индексирующее выражение должно быть перенесено на следующую строку или само по себе занимает несколько строк, сделайте отступ в индексирующем выражении и добавьте новые строки после открывающей квадратной скобки и перед закрывающей квадратной скобкой:

fn main() {
    foo[42];
    &foo[..10];
    bar[0..100];
    foo[4 + 5 / bar];
    a_long_target[
        a_long_indexing_expression
    ];
}

            

Унарные операции

Не ставьте пробел между унарным оператором и его операндом:

!x // ok
! x // nope

                  
Однако после &mut пробел должен быть. Избегайте разрыва строки между унарным оператором и его операндом.



Бинарные операции

Обязательно включайте пробелы вокруг бинарных операций, включая = и другие операторы присваивания, такие как += или *=:

x + 1 // ok
x += 1 // ok
x+=1 // nope
x+1 // nope

                  
Для операторов сравнения помните, что для T op U также реализован &T op &U. И если у вас есть t: &T и u: U, предпочтительнее явно сравнивать по значениям, используя *t op u вместо t op &u. Как правило, в выражениях предпочтительнее разыменование ссылок, если только это не требуется для избежания неоправданно дорогостоящей операции.

Используйте круглые скобки. Не обязательно опускать их из-за приоритета операций. Инструменты не должны автоматически вставлять или удалять круглые скобки. Не используйте пробелы для указания приоритета.

В случае разбиения на строки делайте отступ в каждой последующей строке. Для операторов присваивания переносите строку после оператора. Для всех остальных операторов ставьте оператор в начале следующей строки. Каждое подвыражение помещайте в отдельную строку:

foo_bar
    + bar
    + baz
    + qux
    + whatever

                  
Предпочитайте разбиение строк по операторам присваивания (=, += и т.д.), а не по другим бинарным операторам.

Если строка разбивается по бинарному оператору (включая операторы присваивания) и первый операнд занимает несколько строк, используйте базовый отступ последней строки первого операнда, и отступайте относительно этого:

impl SomeType {
    fn method(&mut self) {
        self.array[array_index as usize]
            .as_mut()
            .expect("thing must exist")
            .extra_info =
                long_long_long_long_long_long_long_long_long_long_long_long_long_long_long;

        self.array[array_index as usize]
            .as_mut()
            .expect("thing must exist")
            .extra_info
                + long_long_long_long_long_long_long_long_long_long_long_long_long_long_long;

        self.array[array_index as usize]
            .as_mut()
            .expect("thing must exist")
            .extra_info = Some(ExtraInfo {
                parent,
                count: count as u16,
                children: children.into_boxed_slice(),
            });
    }
}

          

Приведение типа as

Ключевое слово as следует правилам форматирования бинарного оператора. Всегда добавляйте пробелы вокруг as, а при переносе строки ставьте разрыв перед ним и никогда после, и делайте отступ на следующей строке. Форматируйте тип с правой стороны, используя правила форматирования типов.

Однако, в отличие от других бинарных операторов, если цепочка последовательных приведений as требует переноса строки и перенос перед первым as достаточен, чтобы остаток поместился в следующей строке, не делайте разрывы перед любым последующим as. Вместо этого оставьте всю последовательность типов в одной строке:

let cstr = very_long_expression()
    as *const str as *const [u8] as *const std::os::raw::c_char;

                  
Если последующая строка по-прежнему требует переноса, делайте разрыв и отступ перед каждым as, как и с другими бинарными операторами.



Управляющие конструкции

Не заключайте выражения if и while в лишние круглые скобки:

if true { // ok
}

if (true) { // nope
}

                  
Используйте дополнительные круглые скобки, если это облегчает понимание арифметического или логического выражения:

(x * 15) + (y * 20) // ok

            

Вызовы функций

Не ставьте пробел между названием функции и открывающей круглой скобкой.

Не ставьте пробел между аргументом и следующей за ним запятой.

Обязательно ставьте пробел между аргументом и предшествующей ему запятой.

Предпочитайте не прерывать строку в вызываемом выражении.



Однострочные вызовы

Не ставьте пробел между именем функции и открывающейся скобкой, между открывающейся скобкой и первым аргументом или между последним аргументом и закрывающейся скобкой. Не ставьте запятую после последнего аргумента.

foo(x, y, z) // ok
foo (x, y, z) // nope
foo( x, y, z) // nope
foo(x, y, z ) // nope
foo(x, y, z,) // nope

             

Многострочные вызовы

Отформатируйте вызов в несколько строк, если вызов функции не является коротким, превышает максимальную ширину строки или любой аргумент, или вызываемый объект многострочные. В этом случае поместите каждый аргумент на отдельную строку с блочным отступом, сделайте разрыв после открывающей и перед закрывающей скобкой и используйте завершающую запятую:

a_function_call(
    arg1,
    a_nested_call(a, b),
)

               

Вызовы методов

Следуйте правилам вызова функций. Не ставьте пробелы вокруг символа точки .:

x.foo().bar().baz(x, y, z); // ok
x. foo().bar().baz(x, y, z); // nope

          

Использование макросов

Если макрос может быть проанализирован как другие конструкции, отформатируйте его согласно стилю этих конструкций. Например, макрос, использующий foo!(a, b, c), может быть проанализирован как вызов функции, игнорируя !, поэтому отформатируйте его, используя правила вызова функций.

Руководство по стилю определяет конкретное форматирование для определённых макросов в языке или стандартной библиотеке. Оно не определяет форматирование для сторонних макросов, даже если они аналогичны макросам в языке или стандартной библиотеке.



Макросы форматной строки

Для макросов, которые принимают форматную строку, форматируйте аргументы перед и после форматной строки в одну строку, если они умещаются. При этом саму форматную строку поместите в отдельную строку. Если аргументы некороткие или не помещаются, расположите каждый аргумент на отдельную строку, как в случае с функцией.

println!(
    "Hello {} and {}",
    name1, name2,
);

assert_eq!(
    x, y,
    "x and y were not equal, see {}",
    reason,
);

            

Цепочки полей и вызовов методов

Цепочка это последовательность обращений к полям вызовов, методов и/или использования try оператора ?. Например, a.b.c().d или foo?.bar().baz?.

По возможности форматируйте цепочку вызовов в одну строку, если она "короткая". При форматировании в несколько строк поместите каждое обращение к полю или вызов метода в цепочке на отдельной строке, вставляя разрыв строки перед . и после любого ?, делая отступ в каждой последующей строке:

let foo = bar
    .baz?
    .qux();

                  
Если длина последней строки первого элемента, включая его отступ, меньше или равна отступу второй строки, объедините первую и вторую строки, если это можно сделать, не нарушая синтаксис. После объединения следует ещё раз проверить, можно ли в дальнейшем объединить новую объединенную строку со следующей строкой по тому же правилу. Этот процесс продолжается до тех пор, пока нельзя будет объединить больше строк.

x.baz?
    .qux()

x.y.z
    .qux()

let foo = x
    .baz?
    .qux();

foo(
    expr1,
    expr2,
).baz?
    .qux();

              

Многострочные элементы

Если какой-либо элемент в цепочке отформатирован в несколько строк, поместите этот элемент и любые последующие элементы в отдельные строки.

a.b.c()?
    .foo(
        an_expr,
        another_expr,
    )
    .bar
    .baz

                  
Обратите внимание, что в приведённом выше примере имеется блочный отступ из-за цепочки и вызова функции.

Старайтесь форматировать всю цепочку в многострочном стиле и каждый элемент в отдельной строке. А не размещать произвольные элементы в несколько строк, а другие в одну строку:

// Ok
self.pre_comment
    .as_ref()
    .map_or(false, |comment| comment.starts_with("//"))

// Nope
self.pre_comment.as_ref().map_or(
    false,
    |comment| comment.starts_with("//"),
)


                  
Выражения управляющих конструкций

В этом разделе рассматриваются if, if let, loop, while, while let и for выражения.

Размещайте ключевые слова, любые начальные выражения и открывающую скобку блока в одну строку, если они помещаются. Применяйте к блоку его обычные правила форматирования.

Если есть элемент else, то поместите закрывающую фигурную скобку else, а также любое последующее предложение и открывающую фигурную скобку в одну строку с одним пробелом перед ключевым словом else и после него:

if ... {
    ...
} else {
    ...
}

if let ... {
    ...
} else if ... {
    ...
} else {
    ...
}

                  
Если необходимо разбить управляющую строку, предпочтительно делать это перед = в выражениях * let и перед in в выражении for, делая отступ в следующей строке. Если управляющая строка по какой-либо причине разделена, поместите открывающую фигурную скобку на отдельную строку без отступа:

while let Some(foo)
    = a_long_expression
{
    ...
}

for foo
    in a_long_expression
{
    ...
}

if a_long_expression
    && another_long_expression
    || a_third_long_expression
{
    ...
}

                  
Если начальное предложение занимает несколько строк и заканчивается одной или несколькими закрывающими круглыми скобками, квадратными скобками или фигурными скобками, и в этой строке больше ничего нет, включая отсутствие отступа за пределами отступа в первой строке выражения управляющей конструкции, то поместите открывающую фигурную скобку блока в конец строки, что и предыдущий пробел:

if !self.config.file_lines().intersects(
    &self.codemap.lookup_line_range(
        stmt.span,
    ),
) {  // Открывающая фигурная скобка в той же строке, что и начальное предложение.
    ...
}

     

Однострочный if else

Размещайте if else или if let else в отдельной строке, если они встречаются в позиции выражения (не являются отдельной инструкцией), содержат единственное предложение else и имеют небольшой размер:

let y = if x { 0 } else { 1 };

// Примеры, которые должны быть многострочными.
let y = if something_very_long {
    not_small
} else {
    also_not_small
};

if x {
    0
} else {
    1
}

      

Комбинируемые выражения

Когда последний аргумент в вызове функции форматируется в несколько строк, форматируйте внешний вызов так, как если бы это был однострочный вызов, если это умещается в одну строку. Примените аналогичное комбинированное форматирование к любым похожим выражениям, которые имеют многострочные списки подвыражений с блочными отступами, разделённые круглыми, кваратными или фигурными скобками:

foo(bar(
    an_expr,
    another_expr,
))

let x = foo(Bar {
    field: whatever,
});

foo(|param| {
    action();
    foo(param)
})

let x = combinable([
    an_expr,
    another_expr,
]);

let arr = [combinable(
    an_expr,
    another_expr,
)];

let x = Thing(an_expr, another_expr, match cond {
    A => 1,
    B => 2,
});

let x = format!("Stuff: {}", [
    an_expr,
    another_expr,
]);

let x = func(an_expr, another_expr, SomeStruct {
    field: this_is_long,
    another_field: 123,
});

                  
Применяйте это правило рекурсивно.

Если последним аргументом является многострочное замыкание с явным блочным выраженим, то применяйте комбинированное форматирование только в том случае, если нет других аргументов-замыканий.

// Комбинируемый
foo(first_arg, x, |param| {
    action();
    foo(param)
})
// Некомбинируемый, поскольку замыкание не является последним аргументом
foo(
    first_arg,
    |param| {
        action();
        foo(param)
    },
    whatever,
)
// Некомбинируемый, поскольку первая строка замыкания слишком длинная
foo(
    first_arg,
    x,
    move |very_long_param_causing_line_to_overflow| -> Bar {
        action();
        foo(param)
    },
)
// Некомбинируемый, поскольку есть более одного аргумента замыкания
foo(
    first_arg,
    |x| x.bar(),
    |param| {
        action();
        foo(param)
    },
)

       

Диапазоны

Не ставьте пробелы в диапазонах:

0..10, x..=y, ..x.len(), foo... // ok
0 ..10 // nope
x.. =y // nope
.. x.len() // nope
foo ... // nope

                  
Если при написании диапазона с указанием как начальной, так и конечной границы строка должна быть разбита внутри диапазона, то разбивайте строку перед оператором диапазона и сделайте блочный отступ для второй строки:

a_long_expression
    ..another_long_expression

                  
Используйте скобки вокруг границ для указания приоритета, если какая-либо из них является составным выражением:

..(x + 1)
(x.f)..(x.f.len())
0..(x - 10)

         

Шестнадцатеричные литералы

В шестнадцатеричных литералах могут использоваться заглавные или строчные буквы, но их нельзя смешивать в одном и том же литерале. В проектах рекомендуется использовать один и тот же регистр для всех литералов. Хотя мы не делаем конкретных рекомендаций относительно выбора между заглавными и строчными буквами.