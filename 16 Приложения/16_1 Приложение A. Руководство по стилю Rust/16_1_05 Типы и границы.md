Типы и границы

Однострочное форматирование
[T] - без пробелов;
 
[T; expr], например, [u32; 42], [Vec<Foo>; 10 * 2 + foo()] - пробел после ; и без пробелов вокруг квадратных скобок;
 
*const T, *mut T - без пробела после * и пробел перед типом T;
 
&'a T, &T, &'a mut T, &mut T - без пробела после & и одинарные пробелы, разделяющие другие слова;
 
unsafe extern "C" fn<'a, 'b, 'c>(T, U, V) -> W или fn() - одинарные пробелы вокруг ключевых слов, символов, и после запятых, и без конечных запятых, а также пробелов вокруг скобок;
 
! - обрабатывается как любое другое имя типа, Name
 
(A, B, C, D) - пробелы после запятых, никаких пробелов вокруг скобок и конечный запятых, если только это не одноразмерных кортеж;
 
<Baz<T> as SomeTrait>::Foo::Bar или Foo::Bar или ::Foo::Bar - без пробелов вокруг :: или угловых скобок, одинарные пробелы вокруг as;
 
Foo::Bar<T, U, V> - пробелы после запятых, без конечных запятых и пробелов вокруг угловых скобок;
 
T + T + T - одинарные пробелы между типом  T и +;
 
impl T + T + T - одинарные пробелы между ключевым словом, типом T, и +.
Не ставьте пробелы вокруг круглых скобок, используемых при указании типов данных. Например, (i32).



Переносы строк

По возможности избегайте переносов строк в описаниях типов. Предпочтительно делать переносы на наружнем уровне:

// ok
Foo<
    Bar,
    Baz<Type1, Type2>,
>
// nope
Foo<Bar, Baz<
    Type1,
    Type2,
>>

                  
Если для размещения типа требуется перенос строки, то в этом разделе указано, где при необходимости следует разбивать такие типы:

При необходимости разбивайте [T; expr] после символа ;;
Разбивайте типы функций в соответствии с правилами объявлений функций;
Разбивайте обобщённые типы (generics) в соответствии с их правилами;
Переносите типы с использованием +, вставляя разрыв перед каждым + и делая блочный отступ в последующих строках. При разбиении таких типов вставляйте разрыв перед каждым +:
impl Clone
    + Copy
    + Debug

Box<
    Clone
    + Copy
    + Debug
>