Очистка всех битов от младшего до i-1-го бита

Напишите программу, которая считывает два целых числа x (i8) и n (u8), очищает все биты от младшего до n-1-го у переменной x и выводит получившееся число в двоичной и десятичной записи в виде сообщений:

x до очистки от 0 до {n-1}-го бита
в двоичной записи: {:b}
в десятичной записи: {}

x после очистки от 0 до {n-1}-го бита
в двоичной записи: {:b}
в десятичной записи: {}
Гарантируется, что n не равен 0!

Тестовые данные ✅
Sample Input 1:
0
7

Sample Output 1:
x до очистки от 0 до 6-го бита
в двоичной записи: 00000000
в десятичной записи: 0

x после очистки от 0 до 6-го бита
в двоичной записи: 00000000
в десятичной записи: 0


Sample Input 2:
3
1

Sample Output 2:
x до очистки от 0 до 0-го бита
в двоичной записи: 00000011
в десятичной записи: 3

x после очистки от 0 до 0-го бита
в двоичной записи: 00000010
в десятичной записи: 2



use std::io;
use std::str::FromStr;

fn input<T: FromStr>() -> T 
where
    T::Err: std::fmt::Debug,
{
    let mut input = String::new();
    std::io::stdin()
        .read_line(&mut input)
        .expect("Failed to read input");
    input.trim().parse::<T>().expect("Failed to parse input")
}

fn main() {       
    let mut x: i8 = input();  
    let mut n: u8 = input();   
    //x = 3;
    //n = 1;

    println!("x до очистки от 0 до {}-го бита", n-1); 
    println!("в двоичной записи: {:08b}", x);     
    println!("в десятичной записи: {}\n", x); 

    println!("x после очистки от 0 до {}-го бита", n-1); 
    println!("в двоичной записи: {:08b}", x & !((1<<n)-1));     
    println!("в десятичной записи: {}\n", x & !((1<<n)-1));        
}



