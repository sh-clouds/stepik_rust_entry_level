Возврат значений

Функции не только могут принимать какие-то данные, но и возвращать значения коду, который их вызывает. Для этого необходимо указать тип возвращаемого значения после соответствующего оператора ->:

fn ret_five() -> i32 {
    /*
    Тело функции
    */
}

И сообщить возвращаемое значение:

fn ret_five() -> i32 {
    5
}

В Rust функции возвращают ровно одно значение, а возвращаемым значением является значение последнего выражения в блоке тела функции. Поскольку в данном примере последним выражением является 5, то его значение и будет возвращено. Для наглядности вызовем эту функцию и выведем её результат:

fn ret_five() -> i32 {
    5
}

fn main() {
    println!("{}", ret_five()); // "5"
}

Как видно, функция ret_five() успешно вернула значение. Также результат может быть сохранён в переменную, для дальнейшей с ней работы:

fn ret_five() -> i32 {
    5
}

fn main() {
    let five = ret_five(); // let five = 5;

    println!("{five}"); // "5"
}

Попытка возврата значения тип которого отличен от возвращаемого типа функции, вызовет ошибку несовпадения типов.

fn ret_five() -> i32 {
    5.5 // ошибка
}

fn main() {
    let five = ret_five();

    println!("{five}");
}

Вывод:

error[E0308]: mismatched types
 --> main.rs:2:5
  |
1 | fn ret_five() -> i32 {
  |                  --- expected `i32` because of return type
2 |     5.5
  |     ^^^ expected `i32`, found floating-point number

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
Сообщение об ошибке указывает, что ожидалось значение типа i32, а получено вещественное число.

Также возврат используют для получения модифицированных значений, переданных в функцию:

fn plus_two(mut x: i32) -> i32 {
    x + 2
}

fn main() {
    let seven = plus_two(5);

    println!("{seven}"); // "7"
}

Помните, что использование ; после выражений делает их инструкциями и возврата значения уже не происходит:

fn plus_two(mut x: i32) -> i32 {
    x + 2; // теперь это инструкция
}

fn main() {
    let seven = plus_two(5);

    println!("{seven}");
}

Поэтому для исправления необходимо либо убрать ;, либо указать x последним в теле функции:

fn plus_two(mut x: i32) -> i32 {
    x + 2; // инструкция
    x // выражение
}

fn main() {
    let seven = plus_two(5);

    println!("{seven}");
}

Игровая площадка ⛱️



Ранний возврат

Для раннего возврата значения и досрочного завершения функции используется ключевое слово return, а после возвращаемое значение:

fn is_five(num: i32) -> bool {
    if num == 5 {
        return true;
    } else {
        return false;
    }
}

fn main() {
    let five = 5;

    println!("Is 5 equal {five}? {}", is_five(five));
}

Если аргументом является число 5, то условие if num == 5 выполниться и return досрочно завершит выполнение функции, вернув true.



Возврат нескольких значений

Если вы думали, что кортежи особо нигде больше не нужны, то встречайте. С их помощью мы можем возвращать из функции несколько значений. Для возврата кортежа достаточно указать его тип (i32, f64):

fn get_tup() -> (i32, f64) {
    (5, 10.5)
}

fn main() {
    let tup = get_tup();

    println!("{:?}", tup); // "(5, 10.5)"
}

В случае массива в квадратных скобках указывается тип элементов массива, а затем через точку с запятой ; их количество:

fn get_arr() -> [i32; 3] {
    [0; 3] // [0, 0, 0]
}

fn main() {
    let array = get_arr();

    println!("{:?}", array); // "[0, 0, 0]"
}



Возврат пустого значения

В начале модуля мы сказали, что определение функции является инструкцией. Теперь пришло время узнать самое интересное, вызов функции есть выражение. Когда мы используем функции без указания возвращаемого значения, то функция неявно возвращает пустое значение, т.е. единичный тип (), имеющий ровно одно значение ().

Так функция:

fn unit_fun() {

}
Есть не что иное, как:

fn unit_fun() -> () {

}
Чтобы удостовериться в этом мы преднамеренно попытаемся вернуть значение из этой функции:

fn unit_fun() {
    5
}

fn main() {
    unit_fun();
}

Попытка запуска данной программы обернется неудачей:

error[E0308]: mismatched types
 --> main.rs:2:5
  |
1 | fn unit_fun() {
  |              - help: try adding a return type: `-> i32`
2 |     5
  |     ^ expected `()`, found integer

error: aborting due to previous error

For more information about this error, try `rustc --explain E0308`.
Как видно из сообщения об ошибке, ожидалось единичное значение (), а получено целое. Давайте укажем вместо 5 нужное значение:

fn unit_fun() {
    ()
}

fn main() {
    unit_fun();
}

Теперь всё работает верно.

Помните, что в функциях единичного типа нет необходимости явного указания ().

Убрав ; после вызова unit_fun() ошибки не будет, поскольку возвращаемый тип unit_fun() и main() одинаков:

fn unit_fun() {
    ()
}

fn main() {
    unit_fun()
}

В завершении стоит сказать, что return может быть использован и в функциях без возвращаемых значений (единичного типа):

fn unit_fun(num: i32) {
    if num == 5 {
        println!("Is {num} equal 5? true");
        return; // return ();
    } else if num == 4 {
        println!("Is {num} equal 4? true");
        return;
    } else if num == 3 {
        println!("Is {num} equal 3? true");
        return;
    } else if num == 2 {
        println!("Is {num} equal 2? true");
        return;
    } else {
        return;
    }
}

fn main() {
    unit_fun(5);
}

Игровая площадка ⛱️

Если аргументом unit_fun() является число 5, то условие if num == 5 выполниться и return досрочно завершит выполнение функции. В этом случае возвращаемое по умолчанию им значение ! приводиться к неявному единичному типу () функции.