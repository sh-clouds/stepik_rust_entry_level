Swap

Напишите программу, которая считывает четыре значения:

Целое число n (i8);
Первая начальная позиция p1 (i8);
Вторая начальная позиция p2 (i8);
Количество обмениваемых бит len (i8).
Программа должна поменять у n местами два участка бит, начало которых определяется вторым (p1) и третьим (p2) считанными значениями размерности len. В конце вывести получившееся число в двоичном и десятичном представлении:

До перестановки
Двоичный вид: {:08b}
Десятичный вид: {}

После перестановки
Двоичный вид: {:08b}
Десятичный вид: {}

                  
Гарантируется, что два набора битов не пересекаются! Отсчет позиций производить справа с нуля! Вычисление нового числа реализуйте в функции swap() !

Тестовые данные ✅

Sample Input:
15
0
4
4

Sample Output:
До перестановки
Двоичный вид: 00001111
Десятичный вид: 15

После перестановки
Двоичный вид: 11110000
Десятичный вид: -16


Напишите программу. Тестируется через stdin → stdout
Верно решили 24 учащихся
Из всех попыток 47% верных



use std::io;
use std::str::FromStr;

fn input<T: FromStr>() -> T 
where
    T::Err: std::fmt::Debug,
{
    let mut input = String::new();
    std::io::stdin()
        .read_line(&mut input)
        .expect("Failed to read input");
    input.trim().parse::<T>().expect("Failed to parse input")
}

fn main() {
    let mut x: i8 = input();
    let mut p1: i8 = input();  
    let mut p2: i8 = input();
    let mut n: i8 = input();   

    //x = 28;
    //p1 = 0;
    //p2 = 3;
    //n = 2;
    
    let mut xsw = swap(x, p1, p2, n);   
    println!("До перестановки");  
    println!("Двоичный вид: {:08b}", x); 
    println!("Десятичный вид: {}", x);  
    
    println!("");     

    println!("После перестановки");  
    println!("Двоичный вид: {:08b}", xsw); 
    println!("Десятичный вид: {}", xsw);          
}

fn swap(x: i8, p1: i8, p2: i8, n: i8) -> i8 {
    let xor = ((x >> p1) ^ (x >> p2)) & ((1u8 << n) - 1) as i8;
    x ^ ((xor << p1) | (xor << p2))
}

