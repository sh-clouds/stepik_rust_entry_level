Определение функции


Функции

Тем временем мы всё ближе к завершению юнгерской подготовки. Настало время изучить и закрепить паруса корабля под названием функции, которые позволят бороздить широты программирования.

Действительно, написание любого крупного проекта состоит в разбиении его на более мелкие части и первым ключом к этому являются функции. Такой подход к программированию делает программу более читабельным и удобным в обслуживании.

Функция - повторно используемый блок кода, выполняющий определенную задачу. Функции являются одним из основных строительных блоков не только Rust, но и программирования в целом. Мы уже знакомы с одной из самых важных функций в языке main, которая является точкой входа программы.

Начнём с простого. Вспомним тему вывода данных, где мы печатали фразу Hello, world!:

fn main() {
     println!("Hello, world!");
}

Изменим сообщение и добавим ещё пару выводов:

fn main() {
    println!("Самая важная вещь в языке программирования — его имя.");
    println!("Язык не будет иметь успеха без хорошего имени.");
    println!("Я недавно придумал очень хорошее имя, теперь осталось изобрести подходящий язык.");
    println!("Дональд Кнут");
}

Согласитесь, выглядит громоздко и засорять подобным кодом основную функцию не очень хорошо. И тут на помощь приходят функции, предназначенные как раз для таких целей, помогая разделить код на более мелкие блоки и делая его более понятным.



Определение функции

Для определения функции используется ключевое слово fn, за которым следует имя функции, пара круглых скобок () в которые прописывают передаваемые параметры и фигурные скобки {}, указывающие компилятору, где начинается и заканчивается тело функции соответственно:

fn function_name() {
    /*
    Тело функции
    */
}

Если функция создаётся с описанием: имени, параметров (если есть) и типа возвращаемого значения (тема последнего урока), то это именуется объявлением. А если описывается ещё и тело, т.е. код, который выполняется внутри функции, то это уже определение функции. Но в Rust подобного разделения нет.

Возможность объявлять отдельно от определений есть в C и C++, поскольку единицей компиляции у них является файл, которому может потребоваться доступ к функции, определённой в другом месте. В Rust же, благодаря crate, определения всегда доступны. Хотя в контексте Rust определение и объявление взаимозаменяемы, для ясности будем использовать термин определение.

Перенесём наш вывод в новую определённую функцию:

fn print_knuth() {
    println!("Самая важная вещь в языке программирования — его имя.");
    println!("Язык не будет иметь успеха без хорошего имени.");
    println!("Я недавно придумал очень хорошее имя, теперь осталось изобрести подходящий язык.");
    println!("Дональд Кнут");
}

fn main() {}
Теперь весь этот вывод не будет загромождать основную функцию, а последующие изменения будут с минимальными затратами.

Определение функции является инструкцией.



Вызов функции

Осталось вызвать функцию print_knuth, введя в main её имя и пара скобок ():

fn print_knuth() {
    println!("Самая важная вещь в языке программирования — его имя.");
    println!("Язык не будет иметь успеха без хорошего имени.");
    println!("Я недавно придумал очень хорошее имя, теперь осталось изобрести подходящий язык.");
    println!("Дональд Кнут");
}

fn main() {
    print_knuth();
}

Игровая площадка ⛱️

Также print_knuth может быть определена после функции main:

fn main() {
    print_knuth();
}

fn print_knuth() {
    println!("Самая важная вещь в языке программирования — его имя.");
    println!("Язык не будет иметь успеха без хорошего имени.");
    println!("Я недавно придумал очень хорошее имя, теперь осталось изобрести подходящий язык.");
    println!("Дональд Кнут");
}

Rust не важно, где определяется функция, главное, чтобы она была в одной области видимости с вызывающим её кодом. Область видимости рассматривается в 14 модуле.



Именование функции

Именование функций соответствует соглашению об именах. Тем не менее название функции должно передавать её назначение (действие).

Наилучшей практикой является создание функции, выполняющая одну задачу согласно её названию. Если функция выполняет несколько задач, особенно не связанных между собой, то её сложнее править и документировать.

