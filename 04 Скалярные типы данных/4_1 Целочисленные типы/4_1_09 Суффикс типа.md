Суффикс типа

Согласитесь, каждый раз аннотировать тип утомительно. Существует способ записывать числа нужного типа так, чтобы компилятор автоматически определял тип без аннотации, а именно механизм вывода / инференции типа (type Inference). Type Inference - процесс, при котором компилятор Rust самостоятельно определяет тип переменной на основе получаемого значения и как переменная используется впоследствии. 

Для вывода типа используются числовые литералы с суффиксами типа, которые буквально описывают себя. Создадим переменную с использованием суффикса типа:

let age = 20u8; // 20u8 - числовой литерал

В этом примере компилятор определит, что число 20 типа u8, и назначит его переменной age.

Числовые литералы также могут использовать символ нижнего подчеркивания _ в качестве визуального разделителя для облегчения чтения числа:

let million = 1_000_000; // запись числа 1000000

Однако следует помнить, что без аннотации или указания суффикса типа по умолчанию назначается тип i32, и если заданный числовой литерал превысит диапазон, компилятор выдаст ошибку:

let trillion = 1_000_000_000_000; // ошибка, превышение диапазона для i32

let trillion: i64 = 1_000_000_000_000; // допустимо, используется аннотация типа

let trillion = 1_000_000_000_000i64; // допустимо, используется суффикс типа

let trillion = 1_000_000_000_000_i64; // допустимо, используется суффикс типа с разделителем


Форматы записи целых чисел

По умолчанию все целочисленные литералы представляются в десятичной системе счисления. Однако Rust позволяет записывать числа в других системах. Так, для записи числа в шестнадцатеричной системе перед числом необходимо указать префикс 0x:

let hex_num: u128 = 0x123456789ABCDEFabcdef; // поддерживаются, заглавные и прописные буквы

let hex_num = 0x123456789ABCDEFabcdef_u128; // суффиксная запись

Таблица 4-4: Запись в различных форматах.

Формат	                 Литерал	    Спецификатор формата
Десятичная	             123_567_89	 
Шестнадцатеричная	     0xff	        :x или :#x
Восьмеричная	         0o77	        :o или :#o
Двоичная	             0b1000_1010	:b или :#b
Байтовая - одиночный символ ASCII (только u8)	b'A'	-

Для вывода числа в нужной системе счисления используются соответствующие спецификаторы формата, указанные в таблице:

fn main() {
    let hex_num = 0x10DEF;

    println!("{:x}", hex_num); // "10def"
    println!("{:X}", hex_num); // "10DEF"
    println!("{:#x}", hex_num); // "0x10def"
    println!("{:#X}", hex_num); // "0x10DEF"
} 

Символ : отделяет выводимый аргумент от его спецификаторов формата:

fn main() {
    let hex_num = 0x10DEF;

    println!("{hex_num:x}"); // "10def"
    println!("{hex_num:X}"); // "10DEF"
    println!("{hex_num:#x}"); // "0x10def"
    println!("{hex_num:#X}"); // "0x10DEF"

    println!("{0:#X}", hex_num); // "0x10DEF"
} 

Флаг # указывает на то, что следует использовать "альтернативную" форму печати. #x и #X предваряют аргумент 0x.

По мере прохождения курса вам будут встречаться всё новые параметры форматной строки. Подробнее вы можете ознакомиться с ними в приложении D.

Игровая площадка ⛱️


Целочисленное переполнение

Теперь, что же происходит, когда значение переменной выходит за пределы. Если попытаться изменить переменную на значение вне этого диапазона, увеличив значение, к примеру, переменной типа i8 до 128 или сделав ниже -128, то произойдёт целочисленное переполнение (integer overflow), которое приведет к одному из двух вариантов поведения:

Если компиляция выполняется в режиме отладки (Debug) то Rust включает проверку на целочисленное переполнение, приводящая программу к панике во время выполнения, если возникнет такая ситуация. Термин паника (panicking) обозначает случай, когда программа завершается с ошибкой. Паника рассматривается в следующих частях.

При компиляции в режиме выпуска (Release), Rust не включает проверки на целочисленное переполнение, вызывающее панику. Вместо этого значение, превышающее верхний или нижний предел типа, переходит к минимальному или максимальному значению для данного типа соответственно:

...    

В случае u16 значение 65536 становится 0, 65537 становится 1 и наоборот -1 -> 65535, -2 -> 65534 и т.д.

А для i16 значение 32768 становится -32768, 32769 становится -32767 и наоборот -32769 -> 32767,
-32770 -> 32766 и т.д. 


