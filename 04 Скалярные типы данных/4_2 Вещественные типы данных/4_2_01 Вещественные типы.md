Вещественные типы

Для представления дробных чисел: -0.5, 3.14159, 100.32, ... используются вещественные типы (floating point type) или, как их ещё называют, типы с плавающей точкой или запятой (floating point), которые в Rust представлены как f32 и f64 в соответствии со стандартом IEEE 754:

f32 - одинарная точность, размер 32 бита:
fn main() {
    let pi: f32 = 3.14; // f32
}

f64 - двойная точность, тип по умолчанию, размер 64 бита:
fn main() {
    let pi = 3.141592; // f64
}

Типом по умолчанию был выбран f64, поскольку на современных процессорах он работает примерно с той же скоростью, что и f32, обладая при этом большей точностью (См. табл. 4-4). Оба типа являются знаковыми.

Таблица 4-4: Точность и диапазоны вещественных типов.

Тип     Точность	    Диапазон
f32	    до 8 знаков	    от −3.4∗1038−3.4∗10 38 до 3.4∗10 38 3.4∗10 38
f64    до 15 знаков	от −1.8∗10308−1.8∗10 308  до 1.8∗10 308 1.8∗10 308
 
Хотим обратить ваше внимание, что во всех задачах на программирование для вещественных типов используется тип f64. Спасибо!


Суффикс типа

Вещественные литералы также поддерживают суффиксное указание типа и символ нижнего подчеркивания _ в качестве визуального разделителя:

fn main() {
    let s_pi = 3.1415_f32; // f32
    let d_pi = 3.141592_f64; // f64
}


Основные вещественные операции

Основные арифметические операции для вещественных чисел аналогичны целым:

fn main() {
    // Сложение
    let sum = 5.5 + 10.5; // 16

    // Вычитание
    let difference = 10.4 - 7.4; // 3

    // Умножение
    let product = 4.0 * 30.0; // 120

    // Деление
    let truncated = -5.0 / 3.0; // -1.66...

    // Деление с остатком
    let remainder = 43.0 % 5.0; // 3
}

Преобразование типов

Rust не поддерживает неявного преобразования базовых типов. При попытке сложения, вычитания и т.д. двух значений разных типов произойдет ошибка:

fn main() {
    let sum = 5.5 + 10; // ошибка, операнд 10 целого типа
}
Решением является использование явного приведения типов, т.е. операнды должны быть одного типа:

fn main() {
    let sum = 5.5 + 10_f64; // 5.5 + 10.0
}
Если же операндами являются переменные, то приведение типов осуществляется с помощью ключевого слова as:

fn main() {
    let i_op = 10;
    let sum = 5.5 as f64 + i_op as f64;

    // Или
    let sum = 5.5 as i32 + i_op;
}