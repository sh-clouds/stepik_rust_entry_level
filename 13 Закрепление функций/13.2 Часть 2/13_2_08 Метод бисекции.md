Метод бисекции

В редакторе кода представлена неполная программа, которую необходимо доделать. 
Программа должна считать точность в виде количества знаков после запятой acc (usize) и 
вывести (до acc знаков) корень на интервале [0; 1] с заданной точностью методом половинного деления 
(бисекции) для следующего уравнения:

3x^3+6x^2+5x−1=0

Алгоритм метода бисекции
Метод половинного деления реализуйте в соответствующей функции bisection() !

Тестовые данные ✅
 
Sample Input:
1

Sample Output:
0.2

Напишите программу. Тестируется через stdin → stdout
Верно решил 61 учащийся
Из всех попыток 33% верных


use std::io;

fn main() {
    let mut input = String::new();
    io::stdin()
        .read_line(&mut input)
        .expect("Не удалось прочитать строку");

    let acc: usize = input.trim().parse().expect("Пожалуйста введите точность");
    let epsilon = powi(10.0, -(acc as i32));
    let root = bisection(0.0, 1.0, epsilon);
    println!("{:.1$}", root, acc);
}

fn f(x: f64) -> f64 {
    3.0 * powi(x, 3) + 6.0 * powi(x, 2) + 5.0 * x - 1.0
}

fn bisection(mut a: f64, mut b: f64, epsilon: f64) -> f64 {
    let mut c = (a + b) / 2.0;

    while (b - a) / 2.0 > epsilon {
        if abs(f(c)) < epsilon {
            return c;
        } else if f(a) * f(c) < 0.0 {
            b = c;
        } else {
            a = c;
        }
        c = (a + b) / 2.0;
    }

    c
}

fn powi(mut base: f64, mut exp: i32) -> f64 {
    if exp == 0 {
        return 1.0;
    }

    if exp < 0 {
        base = 1.0 / base;
        exp = -exp;
    }

    let mut result = 1.0;
    while exp > 0 {
        if exp % 2 == 1 {
            result *= base;
        }
        base *= base;
        exp /= 2;
    }

    result
}

fn abs(num: f64) -> f64 {
    if num < 0.0 {
        return -num;
    } else {
        return num;
    }
}

