log_b a 

В редакторе кода представлена неполная программа, которую необходимо доделать. Программа должна считать два положительных вещественных числа a и b, а затем вывести (до 10 знаков) значение log_b a. Гарантируется, что 
b>0, b≠1, a>0!


Для вычисления log_b a можно использовать натуральный логарифм ln и преобразовать его к логарифму по нужному основанию с помощью следующей формулы:

log_b a=ln a/ln b;

 
Для вычисления натурального логарифма 
ln
⁡
(
x
)
ln(x) можно использовать ряд Меркатора:

ln(1+x)= x − x^2/2 + x^3/3 − x^4/4 +⋯.

Этот ряд сходится для −1<x≤1. Ряд Меркатора непригоден для реальных расчётов, так как сходится очень медленно, причём в ограниченном интервале. Чтобы вычислить ln(x) для произвольного x можно использовать его модифицированный вариант, предложенный Джеймсом Грегори:

ln(1+x / 1−x) = 2 * ( x + x^3/3 + x^5/5 + x^7/7  ⋯).


Этот ряд сходится быстрее, а кроме того, левая часть формулы теперь может выразить логарифм любого положительного числа.
...

Данный алгоритм уже пригоден для реальных численных расчётов значений логарифмов, однако не является наилучшим с точки зрения трудоёмкости. Существуют более эффективные алгоритмы.

Вычисления log_b a и lnx реализуйте в соответствующих функциях log_base() и ln() ! Для достижения достаточной точности используете погрешность 1*e^−10.


Тестовые данные ✅

Sample Input:
4
2

Sample Output:
2.0000000000

Напишите программу. Тестируется через stdin → stdout
Верно решили 62 учащихся
Из всех попыток 47% верных



use std::io;

fn main() {
    let mut input = String::new();
    io::stdin()
        .read_line(&mut input)
        .expect("Не удалось прочитать строку");

    let n: f64 = input
        .trim()
        .parse()
        .expect("Пожалуйста, введите вещественное число");

    input.clear();
    io::stdin()
        .read_line(&mut input)
        .expect("Не удалось прочитать строку");

    let b: f64 = input
        .trim()
        .parse()
        .expect("Пожалуйста, введите вещественное число");

    println!("{:.10}", log_base(n, b));
}

fn ln(x: f64) -> f64 {
    // Преобразуем x в y для использования ряда
    let y = (x - 1.0) / (x + 1.0);
    let mut sum = 0.0;
    let mut term = y;
    let mut n = 1;

    let epsilon = 1e-10;

    // Суммируем ряд, пока член больше требуемой точности
    while abs(term) > epsilon {
        sum += term / (n as f64);
        n += 2;
        term *= y * y;
    }

    2.0 * sum
}

fn log_base(n: f64, b: f64) -> f64 {
    ln(n) / ln(b)
}

fn abs(num: f64) -> f64 {
    if num < 0.0 {
        return -num;
    } else {
        return num;
    }
}

