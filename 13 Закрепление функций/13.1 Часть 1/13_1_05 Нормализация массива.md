Нормализация массива

В редакторе кода представлена неполная программа, которую необходимо доделать. Программа должна считать 20 целых чисел в массив и вывести (до 2 знаков) получившуюся коллекцию в нормализованном виде в диапазоне от 0 до 1, как показано в примерах. Нормализация выполняется по следующей формуле:

x′= (x−min) / (max−min),

где x - это исходное значение, 
min и max - минимальное и максимальное значения массива соответственно, а 
x′- нормализованное значение.

Нормализацию реализуйте в функции norm_arr() !

Тестовые данные ✅

Sample Input:
1
7
9
7
0
8
10
2
9
4
0
1
8
1
3
0
10
4
5
8

Sample Output:
[0.10, 0.70, 0.90, 0.70, 0.00, 0.80, 1.00, 0.20, 0.90, 0.40, 0.00, 0.10, 0.80, 0.10, 0.30, 0.00, 1.00, 0.40, 0.50, 0.80]

Напишите программу. Тестируется через stdin → stdout
Верно решили 25 учащихся
Из всех попыток 33% верных


use std::io;
use std::str::FromStr;

fn input<T: FromStr>() -> T 
where
    T::Err: std::fmt::Debug,
{
    let mut input = String::new();
    std::io::stdin()
        .read_line(&mut input)
        .expect("Failed to read input");
    input.trim().parse::<T>().expect("Failed to parse input")
}

fn main() {
    let mut array = [0_i32; 20]; 
    let mut arr = [0.00_f64; 20]; 

    for i in 0..20  
    {       
        array[i] = input();
    }  
    arr = norm_arr(array);
    println!("{arr:.2?}");
}

fn norm_arr(array: [i32; 20]) -> [f64; 20] {
    let mut min : i32 = array[0];
    let mut max : i32 = array[0];
    let mut norm_array = [0.00_f64; 20]; 
    
    for i in 0..20  
    {   
        if min > array[i]
        {
            min = array[i];
        }
        if max < array[i]
        {
            max = array[i];
        }
    }
    
    if min == max 
    {
        return norm_array;
    }
    
    for i in 0..20  
    {   
        norm_array[i] = ((array[i] - min) as f64) / ((max - min) as f64)               
    }    
    norm_array
}

