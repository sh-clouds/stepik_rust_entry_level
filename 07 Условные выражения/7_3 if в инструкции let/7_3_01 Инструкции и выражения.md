Инструкции и выражения

В отличие от большинства других языков, Rust является языком, основанным на выражениях. Это важное отличие необходимо понимать:

Инструкция (Statement) - наименьшая единица языка, выполняющая какое-то действие без возврата значения.
Выражение (Expression) - вычисляемый фрагмент кода с возвратом значения.
В Rust есть два типа инструкций:

Инструкции-объявления (Declaration statements) - вводят одно или несколько имён во включающий блок инструкций, т.е. в {}.

Инструкции-выражения (Expression statements) - вычисляют выражение и игнорируют его результат.
На самом деле мы уже использовали инструкции и выражения. Создание переменной и присвоение ей значения с помощью ключевого слова let является инструкцией-объявления:

fn main() {
    let num = 3;
}

В этом примере let num = 3; это инструкция. Как мы уже узнали, инструкции не возвращают значения. Следовательно,  попытка присвоить let инструкцию другой переменной вызовет ошибку:

fn main() {
    let num1 = (let num2 = 5); // ошибка
}

Инструкция let num2 = 5 не возвращает значение, поэтому не с чем связать переменную num1. В языках по типу C и С++ присваивание возвращает присвоенное значение. В них можно написать num1 = num2 = 5, и обе переменные num1 и num2 будут иметь значение 5. Но не в Rust. 

Выражения же вычисляют значение и составляют большую часть кода на Rust. Рассмотрим математическую операцию сложения 10 + 5, которая является выражением, вычисляющим значение 15. Выражения могут быть частью инструкций, как 3 в инструкции let num1 = 3;, являющийся выражением. Поэтому числа сами по себе также являются выражениями. Больше о выражениях будете узнавать по мере прохождения курса.

if в инструкции let
Поскольку if является выражением и может возвращать значения, его можно использовать в правой части инструкции let для присвоения результата переменной:

fn main() {
    let cond = true;
    let num = if cond { 10 } else { 5 };

    println!("Значение переменной num = {num}"); // "Значение переменной num = 10"
}

В данном случае значение всего выражения if зависит от того, какой блок выполниться. Поскольку cond = true, будет выполнена ветка if, и переменная num будет привязана к значению, которое является результатом ветки if, т.е. 10.



Инициализация переменной выражением if не влияет на правило отделения инструкций завершающей точкой с запятой. Поэтому не забываем ставить ; в конце инструкций.

Важно, что значения, которые могут быть результатами каждого из ветвей if, должны быть одного типа:

fn main() {
    let cond = true;
    let num = if cond { 10 } else { 5.0 }; // ошибка, возвращаемые значения разного типа

    println!("Значение переменной num = {num}");
}

Если типы не совпадают, как в этом примере, мы получим ошибку.

Ветки условий при этом не ограничиваются только одиночными числами. В них могут быть и другие выражения и инструкции:

fn main() {
    let flag = 0;
    let num = if flag == 0 {
        let x = 10;
        x + 1
    } else {
        let x = 10;
        x + 1
    };

    println!("Значение переменной num = {num}"); // "Значение переменной num = 11"
}

Обратите внимание, что строка x + 1 не имеет точки с запятой в конце. Выражения не содержат завершающих ;. Если вы добавите точку с запятой в конец выражения, вы сделайте из него инструкцию, и тогда оно не будет возвращать значение. Помните об этом при работе с выражениями.

И последнее. При использовании if в качестве инициализатора блок else должен присутствовать обязательно!

fn main() {
    let cond = true;
    let num = if cond { 10 }; // ошибка отсутствует блок else

    println!("Значение переменной num = {num}");
}