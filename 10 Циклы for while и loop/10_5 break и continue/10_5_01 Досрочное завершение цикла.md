Досрочное завершение цикла

Иногда бывает необходимо досрочно завершить цикл. Выражение потока управления break позволяет досрочно завершить цикл, внутри которого он объявлен:

fn main() {
    let num = 0;

    while num < 5 {
        break;
    }
}

Игровая площадка ⛱️

while завершиться сразу же после выполнения break. Однако в этом случае досрочное завершение не представляет какого-либо смысла. Куда более полезным и нужным break становиться в сочетании с if.

Решим задачку нахождения первого элемента массива, который нацело делится на 3. 

Определим массив arr:

fn main() {
    let mut arr = [1, 2, 4, 7, 9, 10, 11];

    for i in arr {

    }
}

Для перебора элементов используем цикл for:

fn main() {
    let mut arr = [1, 2, 4, 7, 9, 10, 11];

    for i in arr {

    }
}

С помощью условия найдём и выведем первый элемент массива, который нацело делится на3:

fn main() {
    let mut arr = [1, 2, 4, 7, 9, 10, 11];

    for i in arr {
        if i % 3 == 0 {
            println!("{i}");
            break;
        }
    }
}

Игровая площадка ⛱️

Как только элемент будет найден, нет смысла дальше перебирать элементы массива и тратить процессорное время. Поэтому выражение break завершит цикл.

Эту задачу можно было также решить с помощью while. Определим массив arr и создадим бесконечный цикл:

fn main() {
    let mut arr = [1, 2, 4, 7, 9, 10, 11];

    while true {

    }
}

Для прохождения по циклу определим индекс i: 

fn main() {
    let mut arr = [1, 2, 4, 7, 9, 10, 11];
    let mut i = 0;

    while true {

    }
}

С помощью условия найдём и выведем первый элемент массива, который нацело делится на 3. Не забываем про увеличение i, иначе каждый раз будет проверяться первый элемент:

fn main() {
    let mut arr = [1, 2, 4, 7, 9, 10, 11];
    let mut i = 0;

    while true {
        if arr[i] % 3 == 0 {
            println!("{}", arr[i]);
            break;
        }
        i += 1;
    }
}

Игровая площадка ⛱️

Однако данный способ подвержен более частым ошибкам. Например, забыв увеличить i, входа в условие не произойдет, а значит цикл никогда не завершиться.

Бывают случаи, когда бесконечные циклы необходимы, но для этого в Rust реализована отдельная конструкция loop, рассматриваемый в следующем уроке.


Досрочный переход

В паре с break идет continue, позволяющий совершить досрочный переход к следующей итерации цикла. Особо полезным становиться в ситуациях с несколькими условиями или когда необходимо пропустить отдельные элементы перебора.

Решим задачку нахождения и вывода всех нечётных чисел:

fn main() {
    let mut arr = [1, 2, 4, 7, 9, 10, 11];

    for i in arr {
        if i % 2 == 0 {
            continue;
        }
        println!("Число {i} нечетное");
    }
}
Игровая площадка ⛱️
Теперь при каждом чётном числе условие будет выполняться, а выражение continue заставит цикл прекратить дальнейшее выполнение тела и перейти к следующему элементу массива.



Использование continue и break за пределами цикла не допускается.

 

Циклы также являются выражениями, возвращающие единичный тип (). Поэтому в случае break и continue разрешается опустить ;, тем самым превращая их из инструкций в выражения:

fn main() {
    let num = 0;

    while num < 5 {
        break // ! -> ()
    }
}

Забегая вперёд, возвращаемым по умолчанию значением выражений потока управления является специальный тип ! именуемый never, который автоматически преобразуется в любой другой требуемый тип. Тип ! означает отсутствие значения.

Для большей наглядности мы можем сохранить значение, которое возвращает while:

fn main() {
    let num = 0;

    let x: () = while num < 5 {
        break // ! -> ()
    };
}