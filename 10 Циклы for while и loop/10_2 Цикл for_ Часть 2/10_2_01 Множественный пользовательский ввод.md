Множественный пользовательский ввод

Ранее для считывания нескольких значений нам приходилось создавать для каждого отдельную переменную. Однако для множественного ввода такой метод не подходит. Пришло время и это переложить на циклы. Перенесём пользовательский ввод с консоли внутрь цикла:

fn main() {
    for i in 0..3 {
        let mut input = String::new();
        std::io::stdin()
            .read_line(&mut input)
            .expect("Ошибка при чтении ввода.");

        let num: i32 = input.trim().parse().expect("Введите целое число.");
        println!("Вы ввели число: {num}");
    }
}

Игровая площадка ⛱️

В данном примере цикл выполниться три раза и столько же пользовательский ввод. Другими словами, программа считает только три значения. Таким образом, с помощью количества итераций мы можем регулировать число вводов.

При объявлении переменных num и особенно input за пределами цикла стоит быть осторожным. В предыдущем примере после каждой итерации все переменные внутри цикла удалялись и создавались заново, что не вызывало проблем с множественным вводом.

Давайте попробуем объявить input перед циклом и добавить вывод её содержимого:

fn main() {
    let mut input = String::new();
    for i in 0..3 {
        std::io::stdin()
            .read_line(&mut input)
            .expect("Ошибка при чтении ввода.");
        println!("Содержимое input: {:#?}", input);

        let num: i32 = input.trim().parse().expect("Введите целое число.");
        println!("Вы ввели число: {num}");
    }
}
Игровая площадка ⛱️

1
Содержимое input: "1\n"
Вы ввели число: 1
2
Содержимое input: "1\n2\n"
thread 'main' panicked at main.rs:7:45:
Введите целое число.: ParseIntError { kind: InvalidDigit }
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace
Как мы видим, программа запаниковала после ввода второго значения. Ошибка произошла при попытке конвертации содержимого input в число. Действительно, если мы посмотрим внимательно на строку Содержимое input: "1\n2\n" то легко обнаружить, в чём причина ошибки. Метод read_line продолжил считывание в input, где после первого ввода хранилась "1\n". Далее trim убрал символ \n и parse попытался преобразовать строку "1\n2" в число, что и вызвало ошибку. Для исправления данной ситуации необходимо после каждого использования input очищать её содержимое с помощью вызова метода clear:

fn main() {
    let mut input = String::new();
    for i in 0..3 {
        std::io::stdin()
            .read_line(&mut input)
            .expect("Ошибка при чтении ввода.");
        println!("Содержимое input: {:#?}", input);

        let num: i32 = input.trim().parse().expect("Введите целое число.");
        println!("Вы ввели число: {num}");

        input.clear();
    }
}



Вещественный диапазон

На сегодня встроенного в диапазон решения для генерации вещественной последовательности нет. Это преднамеренное решение разработчиков Rust и не в последнюю очередь из-за особенностей представления вещественных чисел, о которых мы не раз говорили. Но выход есть!

Одним из способов превратить целые числа диапазона в вещественные является конвертация типа:

fn main() {
    for i in 0..10 {
        println!("{:.3}", i as f64);
    }
}