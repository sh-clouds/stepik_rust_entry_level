Массивы

Как и кортежи, массивы (arrays) предназначены для создания коллекций из нескольких значений и имеют фиксированный размер. Создание массива схоже с кортежом, только значения массива записываются внутри квадратных скобок [].

fn main() {
    let a = [1, 2, 3];
}

Главным отличием массива является поддержка только однотипных значений:

fn main() {
    let a = [1, 2.5, 3]; // ошибка, массив должен содержать значения одного типа
}

Многие зададутся вопросом, зачем тогда массивы, если кортежи делают аналогичную функцию, да, но не совсем:

Массив размещается в стеке (тема 14 модуля), а элементы расположены последовательно друг за другом;
Массив поддерживает индексацию;
Поддержка только однотипных значений;
Цикл (тема 10 модуля) for поддерживает перебор массивов, но не кортежей.


Правила создания одноразмерного кортежа не распространяются на массив:

fn main() {
    let tup = (15,); // ок
    let var = (15); // целочисленная переменная

    let arr1 = [15,]; // ок
    let arr2 = [15]; // ок
}

Вспомним правило, что без аннотации или суффикса типом по умолчанию для целых чисел является i32, а для вещественных f64. Определим массив из первого примера с использованием аннотации. Для этого в квадратных скобках обозначается тип элементов массива, а затем количество элементов через точку с запятой ;:

fn main() {
    let arr: [u8; 3] = [1, 2, 3]; // аннотация
}

В контексте массивов для определения типа элементов может использоваться вывод типа:

fn main() {
    let arr = [1_u8, 2, 3]; // инференция (вывод) типа, arr: [u8; 3]
}

Также можно использовать объявление с последующей инициализацией:

fn main() {
    let arr1: [f32; 3];
    arr1 = [1.2, 2.0, 3.2];

    // Или
    let arr2;
    arr2 = [1.2, 2.0, 3.2];
}

Rust предоставляет средство для быстрой инициализации массива одним и тем же значением, указав его квадратных скобках вместо типа, а затем через ; длину массива:

fn main() {
    let z_arr1 = [0; 7]; // [0, 0, 0, 0, 0, 0, 0]

    //Сравните
    let z_arr2 = [0, 0, 0, 0, 0, 0, 0];
}

Для удобной печати всего массива используем спецификатор формата :? в заполнители {}, как было с кортежами. При этом ограничение в 12 символов на массивы не распространяется:

fn main() {
    let z_arr = [0; 13]; // [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]

    println!("{:?}", z_arr)
}

Игровая площадка ⛱️

На, что ещё хотелось бы обратить ваше внимание. Да, длина массива может быть задана только во время компиляции литералом или константной переменной (тема 14 модуля):

fn main() {
    let length: usize = 2000;
    let arr = [0; length]; // ошибка, попытка использовать непостоянное значение на месте константы
}

Доступ к элементам массива

Получение значений массива происходит с помощью индексации. Для этого в квадратных скобках [] указывается индекс элемента. Индексация начинается с 0:

fn main() {
    let a = [1, 2, 3];

    let first = a[0]; // first = 1
    let second = a[1]; // second = 2
}

Поскольку массивы поддерживают индексацию, давайте обратимся к элементу с помощью переменной, хранящей индекс:

fn main() {
    let a = [1, 2, 3];
    let (first, second, third) = (0, 1, 2);

    println!("{}, {}, {}", a[first], a[second], a[third]); // "1, 2, 3"
}

Если во время компиляции произойдет попытка получения доступа к элементу массива, находящемуся за его пределами, компилятор выдаст ошибку, а если во время выполнения, то вызовет панику программы.

fn main() {
    let a = [1, 2, 3];

    let err = a[4]; // ошибка, выход за пределы массива
}

В массивах, как и в кортежах, можно изменять только имеющиеся значения. Для этого массив должен быть mut:

fn main() {
    let mut arr = [2.5, 1.5, 3.6];
    arr[0] = 10.0;

    println!("{}, {}, {}", arr[0], arr[1], arr[2]); // "10, 1.5, 3.6"
}

Индексные переменные должны быть типа usize:

fn main() {
    let mut arr = [2.5, 1.5, 3.6];

    let index: usize = 0;
    arr[index] = 10.0;

    println!("{}, {}, {}", arr[0], arr[1], arr[2]); // "10, 1.5, 3.6"
}