Деструктуризация

Значения массива также могут быть деструктуризированы:

fn main() {
    let arr = [1, 2, 3, 4, 5];

    let [first, second, third, fourth, fifth] = arr; // деструктуризация

    println!(
        "first = {first}, second = {second}, third = {third}, fourth = {fourth}, fifth = {fifth}"
    );

    // "first = 1, second = 2, third = 3, fourth = 4, fifth = 5"
}

Игровая площадка ⛱️

Пустой массив

В отличие от пустого кортежа, пустой массив не может обладать единичным типом:

fn main() {
    let emp_arr: [i32; 0] = [];
    // Или
    let emp_arr: [i32; 0];
    // Или
    let emp_arr = [0u8; 0];
}

И его нельзя задать просто квадратными скобками [] без дальнейшего приведения или вывода типа:

fn main() {
    let emp_arr = [];
    emp_arr as [i32; 0]; // приведение типа
    // Или
    let emp_arr = []; // [i32; 0]
    println!("{}", emp_arr.iter().sum::<i32>()); // выведет сумму элементов, т.е. 0
}

Не обращайте внимания на строчку emp_arr.iter().sum::<i32>() поскольку она приводиться только для демонстрации вывода типа.

Учитывая, что пустые кортежи и массивы неизменяемы, смысла в их использовании мы не видим.