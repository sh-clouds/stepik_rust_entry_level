Составные типы данных

Помимо скалярных величин, которые хранят только одно значение, есть составные типы, состоящие из нескольких значений или типов данных. Справедливо отметить, что составные типы являются структурами данных, однако обратное верно не всегда. В Rust базовыми составными типами являются: кортежи и массивы.

Кортежи

Кортеж (tuple) это коллекция (collection) с фиксированным количеством значений разных типов. Создание кортежа схоже с определением переменной, только значения кортежа записываются внутри круглых скобок () отделяясь запятой ,. Каждое значение кортежа имеет тип, причём они могут быть разными:

fn main() {
    let tup = (500, 6.4, 'h', "Hello"); // (i32, f64, char, &str)
}

В этом примере определена кортежная переменная tup, в которой хранятся четыре значения. Для определения одноразмерного кортежа необходимо поставить запятую после значения, чтобы компилятор отличил литерал от кортежа:

fn main() {
    let tup = (15,); // кортеж

    let var = (15); // целочисленная переменная
}

Следует помнить, что без аннотации или суффикса типом по умолчанию для целых чисел является i32, а для вещественных -f64. Определим кортеж из первого примера с использованием аннотации:

fn main() {
    let a_tup: (i16, f32, char) = (500, 6.4, 'h'); // аннотация
    let s_tup = (500_i16, 6.4_f32, 1_u8); // суффикс типа
}

Теперь в s_tup число 500 типа i16, 6.4 типа f32, а 1 типа u8.

Также можно использовать объявление с последующей инициализацией:

fn main() {
    let tup1: (i32, f64, u8);
    tup1 = (1, 2.0, 3);

    // Или
    let tup2;
    tup2 = (1, 2.0, 3);
}

Помимо литеральной инициализации, в качестве значений могут быть заданы переменные:

fn main() {
    let hello = "Hello";
    let world = "world";
    let tup = (hello, world); // "("Hello", "world")"
}


Помните, что переменные должны быть инициализированы, прежде чем они будут использованы.


Доступ к элементам кортежа

Для получения значения кортежа используется оператор доступа к элементу точка . за которым следует номер значения.

fn main() {
    let tup: (i16, f32, u8) = (500, 6.4, 1);
    println!("{}, {}, {}", tup.0, tup.1, tup.2); // "500, 6.4, 1"
}

Как и в других языках, в Rust нумерация и индексация начинается с 0. Поэтому номер последнего элемента всегда на единицу меньше длины коллекции.

Важно отметить, что кортежи не поддерживают индексацию. Это означает, что нельзя использовать в качестве номера переменную:

fn main() {
    let tup= (500, 6.4, 1);
    let ind = 0;

    println!("{}", tup.ind); // ошибка
}

Игровая площадка ⛱️

Кортеж обладает фиксированной длиной, что значит после объявления нельзя добавить или удалить элемент, но можно изменить имеющиеся, при этом кортеж должен быть mut, а тип назначаемого значения должен совпадать с заменяемым:

fn main() {
    let mut tup: (i16, f32, u8) = (500, 6.4, 1);
    tup.0 = 1.5; // ошибка несовпадение типов должен быть i16
    tup.0 = 1000; // ок

    println!("{}, {}, {}", tup.0, tup.1, tup.2); // "1000, 6.4, 1"
}

Для быстрой и удобной печати нескалярных переменных используйте спецификатор формата :?:

fn main() {
    let mut tup: (i16, f32, u8) = (500, 6.4, 1);
    tup.0 = 1000;

    println!("{:?}", tup); // "(1000, 6.4, 1)"
}

Игровая площадка ⛱️

Спецификатор :? ограничен выводом 12 элементов, поэтому попытка печати кортежа размерностью 13 вызовет ошибку: 

fn main() {
    let too_long_tuple = (1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13);
    println!("tup = {:?}", too_long_tuple); // ошибка, слишком длинный кортеж
}

Перед тем как продолжить, ознакомьтесь с правилами форматирования "Кортежные литералы". 