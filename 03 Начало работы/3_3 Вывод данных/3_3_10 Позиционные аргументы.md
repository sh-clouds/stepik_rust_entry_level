Позиционные аргументы

Форматные строки могут иметь позиционные аргументы в качестве заполнителей. Для этого необходимо указать позиционный аргумент внутри заполнителя, используя индекс. Отсчёт при этом начинается с 0:

fn main() {
    let x = 1;
    let y = 2;
    let z = 3;

    println!("x = {0}, y = {1}, z = {2}", x, y, z); // "x = 1, y = 2, z = 3"
}
Игровая площадка ⛱️
Основным преимуществом использования позиционных аргументов является возможность управления порядком отображения:

fn main() {
    let x = 1;
    let y = 2;
    let z = 3;

    println!("x = {2}, y = {0}, z = {1}", x, y, z); // "x = 3, y = 1, z = 2"
}
Rust позволяет комбинировать явное указание позиции с пустым заполнителем не влияя друг на друга:

fn main() {
    println!("{1} {} {0} {}", 1, 2); // "2 1 1 2"
}
По умолчанию, если в фигурных скобках не указан индекс, Rust автоматически использует следующий по порядку аргумент, независимо от позиционных аргументов. В данном случае первый пустой заполнитель {} указывает на первый аргумент 1. Второй пустой заполнитель - уже на второй аргумент 2. Спецификатор "следующий аргумент" можно рассматривать как итератор по аргументам. Каждый раз, когда встречается спецификатор "следующий аргумент" итератор продвигается.

Также можно ссылаться на один и тот же аргумент более одного раза:

fn main() {
    println!("{1} {1} {0} {0}", 1, 2); // "2 2 1 1"
}
Форматная строка должна использовать все свои аргументы, в противном случае будет ошибка:

fn main() {
    println!("{0} {0}", 1, 2); // ошибка, аргумент 2 не используется
    println!("{}", 1, 2); // аналогично
}
Именованные аргументы
Кроме этого, макросы могут использовать именованные аргументы, которые можно использовать внутри заполнителей в форматной строке:

fn main() {
    let x = 1;
    let y = 2;
    let z = 3;

    println!("{} + {} + {} = {sum}", x, y, z, sum = x + y + z);
}
В данном примере sum представляет собой именованный аргумент.

Если именованный аргумент отсутствует в списке аргументов, то будет использована переменная с таким же именем в текущей области:

fn main() {
    let x = 1;
    let y = 2;
    let z = 3;
    let sum = x + y + z;

    println!("{} + {} + {} = {sum}", x, y, z);
}
Недопустимо помещать позиционные аргументы после именованных:

fn main() {
    let x = 1;
    let y = 2;
    let z = 3;

    // ошибка! z не может следовать после именнованного аргумента sum
    // z должен быть перед именнованным аргументом sum
    println!("{0} + {1} + {3} = {sum}", x, y, sum = x + y + z, z);
}
Как и в случае с позиционными, все предоставленные именованные аргументы должны использоваться.

Забегая вперёд, Rust не имеет Python-подобного эквивалента именованных аргументов функции.