Изменяемые ссылки

Ссылки, подобно переменным, по умолчанию неизменяемы. Нам не разрешено изменять то, на что у нас есть ссылка. Есть три аспекта, которые нужно учитывать, а именно изменяемости чего мы хотим:

Изменяемости значения, на которое указывает ссылка ?
Изменяемости самой ссылки ?
Или оба варианта одновременно ?



Изменяемость значения

Начнём с первого пункта. Для изменения заимствованного значения необходимо после & использовать уже знакомый нам mut. При этом владелец val_a обязательно должен быть изменяемым:

fn main() {
    let mut val_a = 5;

    let ref_a: &mut i32 = &mut val_a;
    
    *ref_a = 10;
}

                  
Подчеркнём, что ключевое слово mut в &mut относится не к ссылке, а к типу, т.е. к i32. Аннотацию типа можно опустить:

fn main() {
    let mut val_a = 5;

    let ref_a = &mut val_a; // let ref_a: &mut i32 = &mut val_a;
    
    *ref_a = 10;
}

                  
Для параметров функций необходимо сделать аналогично:

fn main() {
    let mut val_a = 5;
    println!("a = {val_a}"); // "a = 5"

    change(&mut val_a);
    println!("a = {val_a}"); // "a = 100"
}

fn change(a: &mut i32) {
    *a = 100; // изменение разрешено
}

                  
Игровая площадка ⛱️

Сначала мы делаем мутабельную переменную val_a. Затем мы создаём изменяемую ссылку с помощью &mut val_a и обновляем сигнатуру функции, чтобы принять изменяемую ссылку с помощью a: &mut i32. Это даёт понять, что change изменит значение, которое заимствует. Теперь вам должна стать ясным конструкция &mut input в пользовательском вводе:

fn main() {
    let mut input = String::new();
    std::io::stdin().read_line(&mut input).expect("Error");
}

                  
Стоит сказать, что для функции change передаваемый ему аргумент является уже не входным, а выходным, поскольку она изменяет исходные данные.

Хорошей практикой является избегание выходных аргументов. Если функция должна изменять чьё-то состояние, реализуйте её для данного типа, т.е. методом. 



Изменяемость самой ссылки

Как вы уже могли догадаться, в этом случае изменяемой ссылке можно назначить другой адрес, на которую она будет указывать, без возможности модификации самого значения. Для этого mut должно быть указано перед именем ссылочной переменной:

fn main() {
    let mut val_a = 5;
    let mut val_b = 10;

    let mut reference: &i32 = &val_a; // reference указывает на val_a

    reference = &val_b; // теперь reference указывает на val_b
}

                  
После инициализации reference мы можем назначить ей новый адрес, но без изменения значения, на которое она указывает. Попытка изменить заимствованное значение приведёт к ошибке и не важно, объявлен владелец mut или нет:

Игровая площадка ⛱️

fn main() {
    let mut val_a = 5;

    let mut reference: &i32 = &val_a; // reference указывает на val_a

    *reference = 20; // ошибка
}

                  

Изменяемость значения и ссылки

Ну и третий пункт. Чтобы сделать изменяемым как саму ссылку, так и заимствованное значение, необходимо объединить предыдущие два шага:

fn main() {
    let mut val_a = 5;
    let mut val_b = 10;

    let mut reference: &mut i32 = &mut val_a;
    *reference = 7; // val_a = 7

    reference = &mut val_b;
    *reference = 8; // val_b = 8
}

                  
Игровая площадка ⛱️



Множественное заимствование

Изменяемые ссылки имеют одно большое ограничение, если на значение уже есть изменяемая ссылка, то других изменяемых ссылок на это же значение быть не должно. Попытка создать две изменяемые ссылки на одно значение завершится ошибкой:

fn main() {
    let mut s = 5;

    let r1 = &mut s;
    let r2 = &mut s; // ошибка заимствования "s"

    println!("{}, {}", r1, r2);
}

                  
Заимствований на значение в один момент времени должно быть не больше одного. В примере первое изменяемое заимствование находится в r1 и должно длиться до тех пор, пока оно не будет использовано. Но между созданием этой изменяемой ссылки и её использованием мы попытались создать другую изменяемую ссылку в r2, которая заимствует те же данные, что и r1. Решением данной проблемы будет создание заимствования после println!():

fn main() {
    let mut s = 5;

    let r1 = &mut s;

    println!("{}", r1);

    let r2 = &mut s; // теперь все ок
}

                  
Или использование выражения блока {} для создания новой области видимости, позволяющей использовать несколько изменяемых ссылок, но не одновременно:

fn main() {
    let mut s = 5;

    {
        let r1 = &mut s;
    } // Здесь r1 удаляется и мы можем сделать новую ссылку.

    let r2 = &mut s;
}

                  
Большинство же языков позволяют изменять значение в любой момент времени, но не Rust. Ограничение, предотвращающее одновременное использование нескольких изменяемых ссылок на одни и те же данные, допускает изменение, но очень контролируемым образом. Преимущество такого ограничения заключается в том, что Rust на этапе компиляции определяет это и предотвращает гонку данных. Гонка данных похожа на состояние гонки и происходит, когда одновременно возникают следующие три сценария:

Несколько указателей (или ссылок) одновременно обращаются к одним и тем же данным;
Минимум один указатель (или ссылка) используется для записи данных.
Отсутствуют механизмы синхронизации доступа к данным, которые бы гарантировали правильную последовательность доступа и избегали гонок данных.
Гонки данных вызывают неопределённое поведение, а их диагностирование и исправление во время выполнения может быть сложным. Rust предотвращает такую проблему, отказываясь компилировать код с гонками данных.

Аналогичное правило применяется и для комбинирования изменяемых и неизменяемых ссылок:

fn main() {
    let mut s = 5;

    let r1 = &s; // допустимо
    let r2 = &s; // допустимо
    let r3 = &mut s; // ошибка

    println!("{}, {}, and {}", r1, r2, r3);
}

                  
Запрещено создание изменяемой ссылки, когда существует хотя бы одна неизменяемая ссылка на то же значение. Пользователи, имеющие неизменяемую ссылку на значение, не ожидают, что это значение будет изменено во время их чтения. Поэтому Rust не разрешает создание изменяемой ссылки на значение, когда уже существует неизменяемая ссылка на него. Однако разрешение нескольких неизменяемых ссылок безопасно, потому что читающие данные ссылки не могут изменять данные и не влияют на другие чтения данных другими частями программы.

Исправление данной проблемы аналогично предыдущему решению:

Создание заимствования после println!():

fn main() {
    let mut s = 5;

    let r1 = &s;
    let r2 = &s;  

    println!("{}, {}", r1, r2);

    let r3 = &mut s; // теперь все ок
}

                  
Или использование выражения блока {} для создания новой области видимости:

fn main() {
    let mut s = 5;

    {
        let r1 = &s;
        let r2 = &s;
    } // Здесь r1 и r2 удаляются и мы можем сделать изменяемую ссылку.

    let r3 = &mut s;
}

                  
Несмотря на то, что ошибки заимствования могут иногда вызывать гнев, помните, что компилятор заранее указывает на потенциальную ошибку (во время компиляции, а не во время выполнения) и точно показывает, в чём проблема. Благодаря этому вы можете избежать неожиданных ситуаций и не тратить время на поиск причин того, почему ваши данные не соответствуют вашим ожиданиям.



Ссылочный перебор коллекций

Рассмотрим поближе механизм работы цикла for для перебора коллекций. Возьмём массив фиксированной длины и просто пройдёмся по нему:

fn main() {
    let array: [i32; 5] = [1, 2, 3, 4, 5];

    for i in array {
    }
}

                  
Мы знаем, что значения массива назначаются переменной i и мы также уже знаем, что любое присваивание регулируется правилами владения. Если тип реализует типаж Copy, при присваивании он будет скопирован, в противном случае перемещен. А теперь обратите внимание на тип массива [i32; 5], если думайте, что значения массива будут копироваться в i, то поздравляем, вы абсолютно правы. Поэтому после перебора право владения останется за переменной array и мы сможем использовать её повторно.

У данного подхода есть минус. При переборе коллекций, тип которых не реализует типаж Copy, право владения будет переходить к переменной i и по выходу из цикла коллекция будет недействительной.

Продемонстрируем это наглядно:

fn main() {
    let array: [String; 3] = ["1".to_string(), "2".to_string(), "3".to_string()];
    for i in array {
    }
}

                  
Сначала мы определили array типа String для хранения строк. Далее мы заполнили массив значениями. Не пугайтесь конструкции "1".to_string() вспомним из урока" Вывод данных", по умолчанию строчные литералы являются типа &str, поэтому их необходимо явно преобразовать в тип String путем вызова соответствующего метода. Перейдем к циклу. Теперь при присваивании значений массива переменной i будет происходить уже не их копирование, а перемещение и новым владельцем будет i. После завершения цикла array уже будет недействителен:

fn main() {
    let array: [String; 3] = ["1".to_string(), "2".to_string(), "3".to_string()];
    for i in array {
    }
    println!("{:?}", array); // ошибка, заимствование перемещенного значения
}

                  
И то же самое, если мы попытаемся назначить i другой переменной:

fn main() {
    let array: [String; 3] = ["1".to_string(), "2".to_string(), "3".to_string()];
    for i in array {
        let new_owner = i; // произошло перемещение, теперь new_owner новый владелец данными array
        println!("{i}"); // ошибка, заимствование перемещенного значения
    }
}

                  
Решением будет передача массива по ссылке:

fn main() {
    let array: [String; 3] = ["1".to_string(), "2".to_string(), "3".to_string()];

    for i in &array { // i теперь типа &String
    }
    println!("{:?}", array); // "["1", "2", "3"]"
}

                  
Теперь переменной i будут присваиваться не сами значения, а их ссылки. Однако правила ссылок никуда не делись и в таком виде значения, на которые указывает i доступны только для чтения:

fn main() {
    let mut array: [i32; 5] = [1, 2, 3, 4, 5];

    for i in &array {
        *i += 1; // ошибка, i типа &i32, а не &mut i32 
    }
}

                  
Если необходимо изменять и косвенные значения, используйте &mut при передаче коллекций:

fn main() {
    let mut array: [i32; 5] = [1, 2, 3, 4, 5];

    for i in &mut array {
        *i += 1;
    }
    println!("{:?}", array); // "[2, 3, 4, 5, 6]"
}

                  
Ну, если вам по какой-то причине понадобиться назначить i новую ссылку, сделайте его тоже mut, но на каждой новой итерации ей будет назначаться адрес элемента массива:

fn main() {
    let mut array: [i32; 5] = [1, 2, 3, 4, 5];

    for mut i in &mut array {
        println!("{i}");
        i = &mut 10000; // теперь i ссылается на новое значение
    } 
}

                  
Конечно, это всё не обязательно было проделывать, а вызвать у коллекции готовые методы, которые делают то же самое. Но тогда вы бы не понимали, как они работают! В действительности для перебора for преобразует коллекцию в итератор (тема следующих частей). Простыми словами, итератор - это структура данных, которая предоставляет последовательный доступ к элементам коллекции. Для этого for по умолчанию применяет к коллекции метод into_iter:

fn main() {
    let array: [i32; 5] = [1, 2, 3, 4, 5];

    for i in array.into_iter() { // то же самое, что for i in array
    }
}

                  
Помимо into_iter, есть ещё два метода iter и iter_mut:

fn main() {
    let mut array: [i32; 5] = [1, 2, 3, 4, 5];

    for i in array.iter() { // то же самое, что for i in &array
    }

    for i in array.iter_mut() { // то же самое, что for i in &mut array
        *i += 1;
    }
}

                  
Отличием into_iter от двух других является контекстное определение, т.е. возврат итератора нужного типа.



Копирование и перезаимствование

Многие типы, в том числе и скалярные всегда реализуют типаж Copy. Однако когда они становятся частью составного, ссылочного и т.д. типа, то уже надо индивидуально смотреть. Когда мы сказали, что значения массива [i32; 5] копируются, каким правилам следовал компилятор ? На какой тип он смотрел, на тип значений i32 или на тип массива [i32; 5] ? Всё уже сказано в документации стандартной библиотеки. Давайте смотреть:

Массив [T; _] реализует Copy, если его реализовывает T - тип элемента;
Массив &[T; _] всегда реализует Copy, независимо от T;
Массив &mut[T; _] никогда не реализует Copy, независимо от T.
Если с первым случаем мы разобрались, то другие требуют пояснения. Ссылки делятся на два типа:

Общие (shared) ссылки &T;
Эксклюзивные, исключительные (exclusive) ссылки &mut T.



Общие ссылки

Общие ссылки &T реализуют Copy, что делает их очень гибкими, позволяя работать с косвенными данными без передачи владения.



Эксклюзивные ссылки

Эксклюзивные ссылки &mut T никогда не реализуют Copy. Вместо этого необходимо использовать их с помощью механизма, называемого повторным заимствованием или перезаимствованием (reborrowing). Рассмотрим пример:

fn main() {
    let array: &mut[i32; 3] = &mut[1, 2, 3];

    for i in array { // i: &mut i32
    }
    println!("{:?}", array); // ошибка, заимствование перемещенного значения
}

                  
Причина ошибки кроется, как было сказано выше, в том, что &mut[T; _] никогда не реализует Copy, поэтому данные будут перемещаться. Решением данной проблемы будет воспользоваться механизмом перезаимствования. Для этого необходимо разыменовать ссылку и заново её создать: либо как &, либо как &mut:

fn main() {
    let array: &mut[i32; 3] = &mut[1, 2, 3];

    for i in &mut *array { // то же самое, что for i in array.into_iter()
    }
    println!("{:?}", array); // ок
}

                  
Конечно, перемещение здесь тоже происходит, но только для повторного заимствования. Этот механизм предотвращает создание в один момент времени множества изменяемых ссылок на одни и те же данные. После цикла массив будет следовать прежнему поведению и во вновь созданном цикле необходимо будет повторить перезаимствование:

fn main() {
    let array: &mut[i32; 3] = &mut[1, 2, 3];

    for i in &mut *array {
    }

    for i in &mut *array {
    }
    println!("{:?}", array); // ок
}

                  
В Rust много неявного перезаимствования. Перезаимствование само по себе является большой темой, но вы должны понимать, что оно существует и именно это позволяет Rust быть удобным и эргономичным, сохраняя при этом безопасность памяти.



Висячие ссылки

В языках программирования с прямым доступом к памяти часто возникает риск создания недействительных, висячих (dangling) ссылок. Это происходит, когда ссылка указывает на участок памяти, который уже был освобожден. В Rust, напротив, компилятор гарантирует, что ссылки никогда не будут висячими: если есть ссылка на какие-то данные, компилятор гарантирует, что данные не выйдут за пределы области видимости до того, как это сделает ссылка. Это означает, что данные не будут освобождены до тех пор, пока существует ссылка на них.

Создадим висячую ссылку, чтобы увидеть, как Rust предотвращает их появление с помощью ошибки во время компиляции:

fn main() {
    let ref_to_nothing = dangle();
}

fn dangle() -> &i32 {
    let s = 5;

    &s
}

                  
Давайте подробнее рассмотрим, что именно происходит на каждом этапе нашего кода dangle:

fn main() {
    let ref_to_nothing = dangle();
}

fn dangle() -> &i32 { // возврат ссылки на целое число
    let num = 5; // num - создание нового числа

    &num // возврат ссылки на число num

} // Здесь num удаляется и память освобождается
  // поэтому возврат num является ошибкой

                  
Поскольку переменная num создается внутри dangle, она будет удалена из памяти при завершении функции. Однако мы пытаемся вернуть ссылку на эту переменную из функции. Это означает, что эта ссылка будет указывать на недопустимую i32. Это нехорошо и Rust не позволит нам сделать это. Решением будет вернуть копию num или переместить, если это значение на куче.



Правила работы со ссылками

Повторим всё, что мы обсудили про ссылки:

В любой момент времени может существовать одна изменяемая ссылка или любое количество неизменяемых ссылок на определенные данные, но не оба типа ссылок одновременно на одни и те же данные. Данный механизм именуется правилом псевдонимов (aliasing);
Все ссылки должны быть действительными, то есть указывать на допустимую область памяти.
Мы не раскрыли данную тему полностью, но разобрали основные моменты, которые необходимо знать на этом этапе. В следующих частях мы будем неоднократно возвращаться к теме ссылок и дополнять наши знания о них.