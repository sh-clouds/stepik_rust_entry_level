Константы

Подобно неизменяемым переменным, в Rust существуют константы. Константы - это постоянные значения. Однако между константами и неизменяемыми переменными есть несколько различий:

Для объявления констант вместо let используется ключевое слово const, за которым следует её имя. Константы требуют аннотации типа:
fn main() {
    const DEGREE = 25; // неправильно, нет аннотации типа
    const DEGREE: i32 = 25; // правильно
}

                  
Нельзя применить mut к константам:
fn main() {
    const mut DEGREE: i32 = 25; // ошибка
}

                  
Константы могут быть заданы только константным выражением, но не значением, вычисленным во время выполнения:
fn main() {
    let mut calc_deg: i32;
    /*
         вычисление переменной calc_deg
    */
    const DEGREE: i32 = calc_deg; // неправильно
    const DEGREE: i32 = 2 * 14 * 10; // правильно
}

                  
Правило именования констант состоит в использовании всех заглавных букв с подчёркиванием между словами:
fn main() {
    const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
}

                  
Константы не имеют фиксированного адреса в памяти. Они встраиваются непосредственно в места использования. Поэтому ссылки на одну и ту же константу не обязательно относятся к одному и тому же адресу памяти.
Константы можно объявлять в любой области видимости, включая глобальную:
const DEGREE: i32 = 25; // определен в глобальной области видимости

fn main() {
    let loc_deg = DEGREE; // допустимо
}

                  
Константы существуют в течение всего времени работы программы в пределах области, в которой они были объявлены. Это свойство делает константы полезными для значений в определенной области вашего приложения, о которых могут знать несколько частей программы, например, скорость света и т.д.
Обозначение жёстко закодированных значений, используемых в программе как константы, позволяет иметь единственное место в коде, которое нужно будет изменить, если в будущем потребуется обновить значение.



 Затенение

Ещё одной особенностью языка является возможность объявить новую переменную с тем же именем, как и у существующей переменной, повторяя использование ключевого слова let следующим образом:

fn main() {
    let x = 5;

    let x = x + 1; // затенение

    {
        let x = x * 2; // затенение
        println!("Значение x внутри локальной области равно {x}");
    }

    println!("Значение x равно {x}");
}

                  
Игровая площадка ⛱️

В этом случае Rustaceans говорят, что первая переменная затеняется (shadowing) второй и в дальнейшем компилятор будет использовать вторую переменную. Вторая переменная принимает любое использование имени переменной на себя до тех пор, пока она либо сама не станет тенью, либо не закончится область видимости.

Rustaceans - неофициальное название программистов на Rust, которые вносят свой вклад в развитие Rust или заинтересованы в его развитии.

Программа сначала привязывает x к значению 5. Затем создаётся новая переменная x, добавляя к предыдущему значению 1, затеняя старую. Далее во внутренней области видимости {} третий оператор let также затеняет x и создаёт новую переменную, умножая предыдущее значение на 2. После выхода из локальной области внутреннее затенение закончится и x станет снова 6.

Затенение отличается от объявления изменяемой переменной тем, что позволяет как бы изменять значение, оставляя переменную неизменяемой. Однако затенение изменяемой переменной и наоборот также допустимо:

fn main() {
    let x = 1;
    let mut x = 2; // затенение
    println!("{x}"); // "2"
}

                  
Затенение часто может помочь в местах, где для переменной необходимо перейти на другой тип. К примеру, программа запрашивает у пользователя, сколько пробелов он хочет разместить между некоторым текстом:

fn main() {
    let spaces = " ";
    let spaces = spaces.len(); 
}

                  
Так, затенение избавляет нас от необходимости создавать две переменные spaces_str и spaces_num. И да, константы не могут быть затенены, а вот метки циклов да:

fn main() {
    'outer: loop {
        println!("Вошли в внешний цикл");

        'inner: loop {
            println!("Вошли во внутренний цикл");

            // Выход из внутреннего цикла
            break 'inner;
        }

        println!("Вышли из внутреннего цикла");

        // Повторное определение метки 'inner' во внутреннем цикле
        'inner: loop {
            println!("Вошли в затененный внутренний цикл");

            // Выход из внешнего цикла с помощью метки 'внешний'
            break 'outer;
        }
        println!("Это никогда не будет напечатано");
    }
    println!("Вышли из внешнего цикла");
}

                  
Затенение - это мощный инструмент, который позволяет писать более лаконичный и выразительный код. Его использование требует осторожности, чтобы не создать путаницу и не снизить читаемость кода.