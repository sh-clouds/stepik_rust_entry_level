Владение и функции

Как и присваивание, аналогичным поведением обладает параметр функции. Если параметр является стековым типом, то передача переменной в функцию приведёт к копированию, а если кучным, то к перемещению. С первым случаем мы уже знакомы, а что насчёт второго:

fn main() {
    let s = String::from("hello");       // s определена и может использоваться

    takes_ownership(s);                  // значение s перемещается в функцию
                                         // s удалена и больше не доступна
}

fn takes_ownership(some_str: String) {
    println!("{}", some_str);            // "hello"

} // Здесь some_str выходит за пределы области видимости, вызывается "drop" и some_str удаляется.

                  
После передачи s в функцию она больше не доступна, т.к. произошло перемещение. Если попытаться использовать её после вызова takes_ownership, то Rust выдаст ошибку времени компиляции:

fn main() {
    let s = String::from("hello");       

    takes_ownership(s);     // значение s перемещается в функцию
    println!("s = {s}");    // ошибка, s переместилась и больше не доступна
}

fn takes_ownership(some_str: String) {
    println!("{}", some_str);

}

                  
Для сравнения добавим передачу переменной на стеке. Сравните:

fn main() {
    let s = String::from("hello");       // s определена и может использоваться

    takes_ownership(s);                  // значение s перемещается в функцию
                                         // s удалена и больше не доступна

    let num = 5;                         // num определена и может использоваться

    makes_copy(num);                     // значение num копируется в функцию
                                         // num все еще доступна
}


fn takes_ownership(some_str: String) {
    println!("{}", some_str);            // "hello"

} // Здесь some_str выходит за пределы области видимости, вызывается "drop" и some_str удаляется.


fn makes_copy(some_int: i32) {
    println!("{}", some_int);            // "5"

} // Здесь some_int выходит за пределы области видимости и удаляется.

     

Возвращение значений и область видимости

Возвращаемые значения также могут передавать право владения. Для этого функция должна возвращать значение,  размещаемое на куче:

fn main() {
    let s1 = gives_own();                 // результат gives_own перемещается в s1 
    println!("s1 = {s1}");                // "s1 = hello"

                                          // s1 все еще доступна

} // Здесь s1 выходит за пределы области видимости, вызывается "drop" и s1 удаляется.

fn gives_own() -> String {
    let some_str = String::from("hello"); // some_string определена и может использоваться

    some_str                              // возврат some_str с последующим перемещением
}

                  
Владение переменной каждый раз следует одному и тому же шаблону: если тип храниться на куче, то присваивание значения другой переменной передает владение. Выход кучной переменной из области видимости влечёт её удаление, если только данные не были перемещены во владение другой переменной.

А что, если мы хотим, чтобы функция использовала значение, но не становилась владельцем ? Согласитесь, утомительно  делать копии аргументам функции, если необходимо их повторно использовать. Для этого в Rust есть возможность использовать значение без передачи права владения с помощью ссылки (следующий урок).